Lispのマクロ
================================================================================

概要
--------------------------------------------------------------------------------

このスライドはLispの基本を確認するとともにLispのマクロを簡単に紹介するものである．
対象読者は，Lispでプログラムを書いたことはあまりないが，Lispに興味がある人．
このスライドでは，とくに言語を指定せず，単にLispと言ったら，Common Lisp，Scheme，
Clojureを指す．また主な言語としてScheme(R7RS)を使用する．

簡単な準備
--------------------------------------------------------------------------------

1. 文法
2. データ
3. 同図像性
4. 評価

空白
--------------------------------------------------------------------------------

空白(*whitespace*)はスペースと改行である．空白は，可読性を改善するために使われ，
そしてトークンどうしを分離するために欠かせいないものとして使われるが，ほかの意味は
けしてない．ここでトークンとは，識別子や数などの，それ以上分解できない字句単位である．
たとえば，後述するドット対(\`\`(M.N)"のように\`\`."で繋ぐ対)においては，
\`\`("と\`\`."と\`\`)"はそれぞれ別のトークンである．空白はどの2つのトークンのあいだの
いくつ出現してもよいが，1つのトークンの途中に出現してはならない．空白は文字列の途中にいくつ
出現してもよく，そこでは空白は無視されない．

注釈
--------------------------------------------------------------------------------

注釈(*comment*)は行末を除いて不可視な文字列である．注釈の行末は空白と
同じように扱われる．行注釈は;から始め行末まで続く．ブロック注釈は#|…|#で括る．
S式注釈は#;をS式の先頭につける

.. code-block:: scheme

    ; 行注釈
    #|
        ブロック注釈
    |#
    #; (S式注釈)

S式
--------------------------------------------------------------------------------

1. 原子(*atom*)はS式である．
2. MとNがS式ならば，(M.N)はS式である．この形のS式をドット対(*dotted pair*)という．
   Mをcar部といい，Nをcdr部という．
3. M_1と，…と，M_nがS式ならば，(M_1…M_n)はS式である．この形のS式をリスト(*list*)という．
4. MがS式で，Cがマクロ文字ならば，CMはS式である．

.. code-block:: scheme

    x           ; atomの例
    (x . x)     ; dotted pairの例
    (x y z)     ; listの例
    'x          ; マクロ文字の例

原子
--------------------------------------------------------------------------------

原子には，nil，シンボル，真偽値，数値，文字列などがある．
nilは()と書く．シンボルはたとえばlambdaと書く．真偽値は
#tおよび#fと書く．数値はたとえば42と書く．文字列はたとえば
"answer"と書く．


.. code-block:: scheme

    ()          ; nil
    x           ; シンボル
    #f          ; 真偽値
    42          ; 数値
    "answer"    ; 文字列


リスト
--------------------------------------------------------------------------------

簡単のため，(M_1…M_n)という形を(M_1.(….(M_n.())))の省略だという
ことにする．たとえば(x y z)は(x.(y.(z.())))の省略である．
(M_1…M_n)という形のS式をリストという．

.. code-block:: scheme

    (x y z)     ; リスト

マクロ文字
--------------------------------------------------------------------------------

簡単のため，'Mという形を(quote M)の省略だということにする．
そのほかのマクロ文字は，(文字によって定義は異なるが，)
必ず，マクロ文字を使わない形のS式に変形できる．

データ
--------------------------------------------------------------------------------

1. 原子はデータである．
2. ドット対はデータである．
3. 手続きオブジェクトはデータである．
4. 継続オブジェクトはデータである．
5. etc

S式はデータである
--------------------------------------------------------------------------------

S式はデータである．S式が原子の形をしている場合は，データの定義によりS式はデータである．
S式がドット対の形をしている場合は，データの定義によりS式はデータである．
S式がリストの形をしている場合は，ドット対の省略形なのでS式はデータである．
S式がマクロ文字の形をしている場合は，マクロ文字を使わない形をしたS式の省略形なので
S式はデータである．以上ですべての場合は尽くされた．

同図像性
--------------------------------------------------------------------------------

LispプログラムはS式として書かれる．S式はデータなので，したがってLispプログラムは
データとして書かれる．このように，プログラムがデータとして書かれる言語は，同図像性を持つ
という．

評価
--------------------------------------------------------------------------------

あるデータVをLispプログラムとして実行し，VからあるデータWへと形が変わることを，V⟹Wと書き，
\`\`VがWへと評価される"と読む．WをVの値という．

.. code-block:: scheme

    (let ((x 42)) x)    ; ⟹ 42

評価規則
--------------------------------------------------------------------------------

* V⟹V (ただしMがシンボルを除く原子の場合)
* x⟹V (ただしxがシンボルで，その評価時点で可視な束縛xにVが格納されている場合)
* (quote V)⟹V
* eval⟹FとなるFが存在し，V⟹Wならば(F V)⟹W．

原子の評価
--------------------------------------------------------------------------------

シンボルを除き，原子は評価されるとそれ自身を返す．
M⟹M．ただしMはnil，真偽値，数値，文字列，関数オブジェクト，または継続オブジェクト．

.. code-block:: scheme

    ()          ; ⟹ ()
    #f          ; ⟹ #f
    42          ; ⟹ 42
    "answer"    ; ⟹ "answer"

シンボルの評価
--------------------------------------------------------------------------------

シンボルの評価には環境(*environment*)が必要である．その地点で有効な環境とは，
プログラムの中のある地点で有効なすべての可視な束縛からなる集合をいう．束縛とは，要するに，
ある記憶領域に束縛された変数のことである．たとえば，ある変数xとその変数に格納された値42
を(x:42)と書く．いま，有効な可視な束縛がそれしかないとすると，環境は{(x:42)}と書く．
{(x:42)}のもとで，x⟹42である．{}のもとで，x⟹エラーである．

.. code-block:: scheme

    x           ; ⟹ v (ただし (x:v)∈環境)
    x           ; ⟹ エラー (ただし (x:v)∉環境)


リストの評価
--------------------------------------------------------------------------------

リストの評価は，大きく分けて3種類ある．まず，特殊形式(*special form*)
と呼ばれるもので，これは，car部が，lambdaやletといったシンボルである場合に適用される．
次に，関数適用．これは，car部が，シンボルで，なおかつその名前の変数に手続きが束縛されている場合
に適用される．最後に，マクロ呼び出し．これは，car部が，マクロとして定義された名前である
場合に適用される．

quote
--------------------------------------------------------------------------------

特殊形式quoteは，与えられた引数をそのまま返す．
(quote V) ⟹ V．Vが評価されないことに注意せよ．

.. code-block:: scheme

    'x          ; ⟹ x

lambda
--------------------------------------------------------------------------------

特殊形式lambdaは手続きオブジェクトをつくる．
(lambda (x_1…x_n) M)のように書く．
x_1…x_nはそれぞれ仮引数をあらわすシンボルである．
(lambda (x_1…x_n) M)⟹手続きオブジェクト．

.. code-block:: scheme

    (lambda (x) x)  ; ⟹ 手続きオブジェクト

関数適用
--------------------------------------------------------------------------------

Vがマクロの名前でもなく特殊形式でもないならば，(V V_1…V_n)という形のリストは，評価されると関数適用とみなされる．
V_1…V_nを引数として，Vを呼び出すということである．V⟹WかつV_1⟹W_1かつ…V_n⟹W_nかつ
(W W_1…W_n)⟹Uならば(V V_1…V_n)⟹U．
V_k⟹W_kは引数はすべて評価されるということをあらわしている．
たとえば，(f x)の場合，V_1≡xだが，fにはxというシンボルが渡されるわけではなく，
x⟹WならばWが渡される．ここでは例を見て理解してほしい．

.. code-block:: scheme

    ((lambda (x) x) 42)     ; ⟹ 42

eval
--------------------------------------------------------------------------------

quoteとは反対に，評価されないデータを評価する関数がevalである．
eval⟹FとなるFが存在し，V⟹Wならば(F V)⟹W．
評価されないS式は，通常は存在しないので，quoteしたものをeval関数に与えることになる．
通常，evalは引数として評価するS式を1つとるが，R7RSでは，evalは評価するS式と
環境の2つをとることに注意せよ．

.. code-block:: scheme

    (eval 'x (interaction-environment))     ; = x
    ; (eval x) とすると，``x を評価したもの"を評価してしまうので注意せよ．

cons
--------------------------------------------------------------------------------

ドット対は(M.N)のように書くが，ドット対をデータ(V.W)として扱うにはどうすれば
よいのだろうか．ひとつの案はquoteを使い(quote (x.y))のようにすることであるが，
これではxとyはシンボルであって変数ではない(評価されない)ことになってしまう．
評価したい場合はcons関数を使い，(cons x y)とする．
cons⟹FとなるFが存在し，(F V W)⟹(V.W)

.. code-block:: scheme

    (cons 'x 'y)     ; ⟹ (x.y)

バッククォートとカンマ
--------------------------------------------------------------------------------

マクロ文字\`とマクロ文字,は対応して使われる．
,は`のなかでしか使うことができない．
\`Mの展開形を次のように帰納的に定義する:

1. Mが原子なら \`M≡'M
2. NがS式で，Mが,Nの形をしているなら \`M≡N
2. Mが(N.R)の形をしているなら \`M≡(cons \`N \`R)

たとえば \`(x ,y z)≡\`(x.(,y.(z.())))≡
(cons \`x \`(,y.(z.())))≡(cons 'x (cons \`,y \`(z.())))≡
(cons 'x (cons y (cons \`z \`())))≡(cons 'x (cons y (cons 'z '())))

準備まとめ
--------------------------------------------------------------------------------

* 空白，注釈は無視される
* 文法はS式．原子，ドット対，リスト，マクロ文字．
* 同図像性(S式はデータである)
* 評価規則．原子の評価，シンボルの評価，リストの評価．quote，lambda，eval，cons，
  バッククォートとカンマ

マクロ
--------------------------------------------------------------------------------

マクロとはLispのコードを返す関数である．マクロとはただの関数であると考えたほうがいい．
特殊な機能だと考えるのは混乱するだけである．
返すのがたまたまLispのコードであるというだけである．
たとえば，関数Fは，Lispのコードを受け取ってLispのコードを返す函数である．
であらば，(eval (F 'M_1…'M_n))のように書けば，それはもはやマクロである．

マクロ適用
--------------------------------------------------------------------------------

とはいえ，いちいち戻り値であるLispのコードを評価するためにevalを書くのは面倒だし，
quoteを書くのもやはり面倒である．簡単のため，FがLispのコードを受け取って
Lispのコードを返す関数の名前だとすると，F*を次のように書けるということにする．
(eval (F 'M_1…'M_n))≡(F* M_1…M_n)

マクロ定義
--------------------------------------------------------------------------------

特殊形式defmacroは，(defmacro x (y_1…y_n) M)のように書く．
xはマクロの名前をあらわすシンボルである．
y_1…y_nはそれぞれ仮引数をあらわすシンボルである．
MはS式である．

例示は理解の試金石
--------------------------------------------------------------------------------

インクリメントを定義する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

例はCommon Lispで書かれていることに注意せよ．

.. code-block:: lisp

    (defmacro ++ (var) `(setf ,var (1+ ,var)))
    (setq i 0)
    (++ i)

簡約1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

マクロは関数のｼﾝﾀｯｸｽｼｭｶﾞ-だと考える

.. code-block:: lisp

    (defun ++ (var) `(setf ,var (1+ ,var)))
    (setq i 0)
    (eval (++ 'i))


簡約2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

インライン展開してみる

.. code-block:: lisp

    (setq i 0)
    (eval '(setf i (1+ i)))

簡約3
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

evalとquoteをどちらもはずす

.. code-block:: lisp

    (setq i 0)
    (setf i (1+ i))

定義の解説1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\`(setf ,var (1+ ,var)) は (cons 'setf (cons var (cons (cons '1+ (cons var nil)) nil)))
と同じである．要は (setf *var* (+1 *var*)) という形のデータをつくるということである．
ただし *var* は引数に置換される．

.. code-block:: lisp

    (defmacro ++ (var) `(setf ,var (1+ ,var)))

定義の解説2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

もし++マクロが関数だとすると， (++ i) は (eval (++ 'i)) のように理解するのがはやい．
つまり， ++ に 'i を与えて，その戻り値 (setf i (1+ i)) を eval するということである．

.. code-block:: lisp

    (setq i 0)
    (++ i)

マクロと同図像性
--------------------------------------------------------------------------------

Lispがマクロのような強力な機能をもつのは，ひとえに同図像性のおかげであろう．
つまり，Lispでは，Lispのソースコード自体を第一級の対象(データ)として扱えるのである．
Lispでは，ソースコードを，関数の引数として渡したり，戻り値として返したりできるのである．

マクロとS式
--------------------------------------------------------------------------------

しばしば，Lispのマクロが強力なのはS式のおかげだといわれるが，じっさいはそうではない．
S式は構文規則を定めるものであってデータではない．重要なのは同図像性であって，構文ではない．
どんな構文であろうと，けっきょくはそれがリストとして扱えるかどうかが重要なのだ．たとえば，
今回扱ったS式は一般的な定義を拡張してリストとマクロ文字を定義に含めた．
そのおかげで関数適用を(f.(x.(y.(z.()))))のように書かなくてよくなったし，
(quote x)を'xと書けるようになった．たとえば，加えて，中置記法{M :N R}は(N M R)の省略だ
ということにしても，マクロが強力なのは変わらない． **S式は重要ではない** ．

各方言のマクロ
--------------------------------------------------------------------------------

いままでは，Lisp一般の話をしてきた．これからは各方言に搭載されている
マクロをザッと見ていく．

1. Common Lisp
2. Scheme
3. Clojure

Common Lispのマクロ
--------------------------------------------------------------------------------

1. キーワード
2. 不健全
3. gemsym
4. コンパイル時に評価される
5. 再帰できない
6. リードマクロ

defmacro
--------------------------------------------------------------------------------

Common Lisp のマクロは， defmacro を使って書く．

.. code-block:: lisp

    (defmacro ++ (var) `(setf ,var (1+ ,var)))
    (setq i 0)
    (++ i)  ; ⟹ 1

不健全
--------------------------------------------------------------------------------

後置デクリメント
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Scheme にいわせれば， Common Lisp のマクロは不健全だという．
その理由は，変数に関する名前解決のルールにある．
たとえば，マクロ内である計算結果をもち回したいので，
一時的な変数にいれたいとする．そのため tmp と名付けることにする．

.. code-block:: lisp

    (defmacro post++ (var)
      `(let ((tmp ,var))
        (setf ,var (1+ ,var))
        tmp))
    (setq i 0)
    (post++ i)  ; ⟹ 0

tmpという変数名は？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

しかし，運悪くtmpという名前の変数名を使っていると，結果が期待したものにはならない．

.. code-block:: lisp

    (setq tmp 0)
    (post++ tmp)  ; ⟹ 1

展開された形の比較
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: lisp

    (setq i 0)
    (let ((tmp i))
      (setf i (1+ i))
      tmp) ; ⟹ 0
    (setq tmp 0)
    (let ((tmp tmp))
      (setf tmp (1+ tmp))
      tmp) ; ⟹ 1

gensym
--------------------------------------------------------------------------------

安全な後置デクリメント
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

不健全であると考えると，一時的な値をなにか変数にいれることができない
ように思える．なぜならば，どんな名前を選んでもそれが使われてしまってはバグが避けられない
からである．しかし，一時的な値に名前をつけることは必要であろう．
そこで， Common Lisp には gensym という関数がある．これは，プログラム内に登場する
いかなるシンボルともかぶらないシンボルを返すものである．

.. code-block:: lisp

    (defmacro post++ (var)
      (let ((tmp (gensym)))
        `(let ((,tmp ,var))
          (setf ,var (1+ ,var))
          ,tmp)))
    (setq tmp 0)
    (post++ tmp)    ; ⟹ 0

gensym の返す値
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: lisp

    (gensym)    ; ⟹ #:G2814

展開された形
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: lisp

    (setq tmp 0)
    (let ((G2814 tmp))
      (setf tmp (1+ tmp))
      G2814) ; ⟹ 0

運が悪かったら？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gensymが運悪く仕様済みのシンボルを返してしまったらバグるのでは？　という疑問を
感じるかもしれない．安心してほしい．それはない．

コンパイル時に評価される
--------------------------------------------------------------------------------

Common Lispのマクロはコンパイル時に評価される．
一部の方々は，この響きだけでゾクゾクと悦びを感じるのではなかろうか．
安心してほしい．もちろんコンパイル時計算もできる．レイトレーシングだって，おそらく
可能だろう．

再帰できない
--------------------------------------------------------------------------------

マクロがコンパイル時に評価されることのいちばんやっかいな点は再帰できないことである．
たとえば，次のようなマクロを(f 42)と呼び出すと停止しない．
ifが評価されるのは実行時で，fが評価されるのはコンパイル時だから，
(if t then (f …)) のようにしても， (f …) の評価は発生してしまうのである．ちなみに，
C++ の template でもよく似た問題が発生する．
さらにやっかいなことに，コンパイルせずインタプリタとして起動すると実行できてしまう．
インタプリタだと，(f …)の評価が発生しないからである．

.. code-block:: lisp

    (defmacro f (x)
      `(if t ,x (f ,x)))

リードマクロ
--------------------------------------------------------------------------------

マクロ文字'や\`みたいなものをユーザが定義することもできる．
たとえば，1引数の関数を書くのにいちいちlambdaというキーワードや仮引数を書くのは
めんどうだから， %it というコードをみつけたら (lambda (it) it) のように展開してくれたら便利
かもしれない．

.. code-block:: lisp

    (set-macro-character #\%
      #'(lambda (stream char)
        (list 'lambda '(it) (read stream t nil t))))
    (funcall %it 42) ; ⟹ 42

Schemeのマクロ
--------------------------------------------------------------------------------

1. define-syntaxとsyntax-rules
2. 健全
3. syntax-case
4. 新しい束縛は追加できない

define-syntaxとsyntax-rules
--------------------------------------------------------------------------------

Scheme のマクロは， define-syntax と syntax-rules を使う

.. code-block:: scheme

    (define-syntax ++
      (syntax-rules ()
        ( (++ var)
          (set! var (+ var 1)))))
    (define i 0)
    (++ i) ; ⟹ 1

健全
--------------------------------------------------------------------------------

Common Lispのマクロと違い，Schemeのマクロは，マクロが返すリストが
新しい束縛をつくる場合は，自動で安全な名前にリネームされる．
たとえば，この例のtmpは，じっさいにはtmpではなく，なにかユーザが使わないような
名前になっている．

.. code-block:: scheme

    (define-syntax post++
      (syntax-rules ()
        ( (++ var)
          (let ((tmp var))
            (set! var (+ var 1))
            tmp))))
    (define tmp 0)
    (post++ tmp) ; ⟹ 0

syntax-case
--------------------------------------------------------------------------------

R6RS では syntax-case というキーワードもあったけど，R7RSではなくなっている．
R6RSは扱わないので，触れるだけにする．

新しい束縛は追加できない
--------------------------------------------------------------------------------

前の前の節で，(let ((tmp …))…)のようにしても変数名がリネームされると
言ったけど，逆に，tmpをローカル変数として追加したりすることはできない．

Clojureのマクロ
--------------------------------------------------------------------------------

1. defmacro
2. 変数補足は発生しない
2. auto-gensym
3. 変数補足を利用できる
4. ディスパッチマクロ

defmacro
--------------------------------------------------------------------------------

Clojure のマクロは， defmacro を使って書く．
ちなみに Clojure は変数の再代入を許していないので，インクリメントを
ただ値を返すだけにする．これではインクリメントである意味がないけど，
例なので許してほしい．また， Clojure ではマクロ文字,の代わりに
マクロ文字~を使う．

.. code-block:: clojure

    (defmacro ++ [var] `(+ ~var 1))
    (def i 0)
    (++ i)  ; ⟹ 1

変数補足は発生しない
--------------------------------------------------------------------------------

たとえば次のように書くと，危険だということでコンパイルエラーになる．
リネームされるというわけではないけど，思わぬバグは発生しにくくなっている．

.. code-block:: clojure

    (defmacro post++ [var]
      `(let [tmp ~var]
        (+ ~var 1)
        tmp))
    (def tmp 0)
    (post++ tmp)

auto-gensym
--------------------------------------------------------------------------------

変数名のあとに # を書くと， gensym で置き換えられる

.. code-block:: clojure

    (defmacro post++ [var]
      `(let [tmp# ~var]
        (+ ~var 1)
        tmp#))
    (def tmp 0)
    (post++ tmp)  ; ⟹ 0


変数補足を利用できる
--------------------------------------------------------------------------------

アナフォリックマクロみたいなものを書きたい場合，シンボルに ~' とつける．
これはマクロ文字~とマクロ文字'の組み合わせではなく，独立したマクロ文字であることに注意

.. code-block:: clojure

    (defmacro aif [x y z]
      `(let [~'it ~x]
        (if ~'it ~y ~z)))
    (aif '(x y z) it nil)   ; ⟹ '(x y z)

ディスパッチマクロ
--------------------------------------------------------------------------------

リードマクロに似たディスパッチマクロというものがある．
これは必ず # から始める必要があるけど基本的にはリードマクロと同じようなものである．

マクロの利用例
--------------------------------------------------------------------------------

マクロの利用例を紹介する．

1. 構文をつくる
2. コンテキストをつくる
3. 毎回入力するのが面倒なものを省略する
4. コンパイル時計算
5. アナフォリックマクロ 
6. 言語をつくる


構文をつくる
--------------------------------------------------------------------------------

おそらくいちばん頻度の高い利用方法がこれで，一般的なLisp方言は，
過半数の構文をライブラリとして実装している．
たとえば，Clojureにはdefとfnという構文がある．(def x y)は，yという値にxという名前をつける．
一方，fnは(fn [x] x)のように書いて無名関数をつくる．すると自然に，関数に名前をつける場合は，
(def f (fn [x] x))のように書くことになる．しかし，このようなコードは頻出する．
あるいは，defのほうかに，関数をつくる構文があると便利かもしれない．そういう場合，マクロを
使って，defnをdefとfnを組み合わせたものとして定義できる．

.. code-block:: clojure

    (defmacro our-defn [name & spec]
      `(def ~name (fn ~@spec)))
    (our-defn f [x] x)

コンテキストをつくる
--------------------------------------------------------------------------------

次に利用する頻度が高いのがたぶんこれであろう．
たとえば，letは新しいコンテキストをつくってローカル変数を導入する．
しかし，もしかしたら，ユーザが新しいローカル変数を導入する構文を
つくりたいかもしれない．例としてはforeachなどがある．
foreachは (foreach item iter body)のように書くとitemをローカル変数として導入したい．
そういう場合，マクロを使えば実現できるだろう．


省略する
--------------------------------------------------------------------------------

プログラムを書いているとき，あなたはおそらく毎回同じようなコードを書くことに
悩まされるはずである．それがある種のルーチンに分離できるものであればいいが，
現実はそうはいかない．たとえば，JavaScriptを書いていて，functionと毎回書くのが面倒だと
いうのは誰もが感じることだろう．そういう場合，マクロを使えば，functionの代わりに
fnというキーワードに変更できる．たとえば，Common Lispではlambdaというキーワードがあるけど，
lambdaは長すぎるからlaにしたいとしよう．それもマクロなら簡単に実現できる．


.. code-block:: lisp

    (defmacro la (x y)
      `(lambda ,x ,y))
    (la (x) x) ; ⟹ #<FUNCTION :LAMBDA (X) X>



コンパイル時計算
--------------------------------------------------------------------------------

ふつうの実装では，マクロの展開はコンパイル時におこなう．
マクロは実行時と同じだけの計算できる．したがって，マクロでコンパイル時計算をおこなうことも
もちろん可能だ．ほとんどのケースでは必要ないだろうが，
もしかしたら，コンパイル時に，定数を計算して定数に展開したいことがあるかも
しれない．そういう場合，マクロを使うと言う選択肢もある．

アナフォリックマクロ 
--------------------------------------------------------------------------------

たとえば， if の条件式で評価された価を then 節で使いたいとか，
while の条件式で評価された価を本体で使いたいということはよくあることだ．
if it = expr…のようにして変数を書く手もあるが，よくあるケースなので it を省略できるように
しておけば便利そうである．マクロは新しい変数が存在するように展開することもできるので，
このようなものも実装できる．

言語をつくる
--------------------------------------------------------------------------------

そう，Lispの本当の力…それは，その言語自体をその言語言語で拡張できることだ．
構文やコンテキストなんてものはささやかなものだ．本当の力は，S式で書かれたまったく別の言語を見たとき
完全に理解できる．普通の人は，型システムをマクロで実装しようなんて思わないだろう．
しかし，条件さえ整えば，動的言語であるLispに強力な型システムを積むことすらできる．
ほかの言語のように，値の型がまちがっていたらエラーにするなんていう動的検査ではない．
本当に静的な検査をやってのけてしまうのだ．実例は， Clojure では core.typed，
Scheme では typed/racket などがある．興味があれば，調べてみてほしい．

終わりに
--------------------------------------------------------------------------------

いかがだっただろうか．Lispのマクロの力をすこしは感じ取って頂けたのではないだろうか．
ともあれここまで読んでくれてありがとう! もしあなたにその気があれば，ぜひ
Lispのうえに(*on lisp*)静的型付き言語を実装してみてほしい．そして高らかにLispを
disるのだ!