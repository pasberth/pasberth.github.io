<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
      <title>Lispのマクロ</title>
    

    <link rel="stylesheet" type="text/css" href="../../_static/main.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
</head>
<body>

    <div class="body">
        
  <div class="section" id="lisp">
<h1>Lispのマクロ<a class="headerlink" href="#lisp" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>概要<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>このスライドはLispの基本を確認するとともにLispのマクロを簡単に紹介するものである．
対象読者は，Lispでプログラムを書いたことはあまりないが，Lispに興味がある人．
このスライドでは，とくに言語を指定せず，単にLispと言ったら，Common Lisp，Scheme，
Clojureを指す．また主な言語としてScheme(R7RS)を使用する．</p>
</div>
<div class="section" id="id2">
<h2>簡単な準備<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>文法</li>
<li>データ</li>
<li>同図像性</li>
<li>評価</li>
</ol>
</div>
<div class="section" id="id3">
<h2>空白<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>空白(<em>whitespace</em>)はスペースと改行である．空白は，可読性を改善するために使われ，
そしてトークンどうしを分離するために欠かせいないものとして使われるが，ほかの意味は
けしてない．ここでトークンとは，識別子や数などの，それ以上分解できない字句単位である．
たとえば，後述するドット対(``(M.N)&#8221;のように``.&#8221;で繋ぐ対)においては，
``(&#8220;と``.&#8221;と``)&#8221;はそれぞれ別のトークンである．空白はどの2つのトークンのあいだの
いくつ出現してもよいが，1つのトークンの途中に出現してはならない．空白は文字列の途中にいくつ
出現してもよく，そこでは空白は無視されない．</p>
</div>
<div class="section" id="id4">
<h2>注釈<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>注釈(<em>comment</em>)は行末を除いて不可視な文字列である．注釈の行末は空白と
同じように扱われる．行注釈は;から始め行末まで続く．ブロック注釈は#|…<a href="#id5"><span class="problematic" id="id6">|</span></a>#で括る．
S式注釈は#;をS式の先頭につける</p>
<div class="highlight-scheme"><pre>; 行注釈
#|
    ブロック注釈
|#
#; (S式注釈)</pre>
</div>
</div>
<div class="section" id="s">
<h2>S式<a class="headerlink" href="#s" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>原子(<em>atom</em>)はS式である．</li>
<li>MとNがS式ならば，(M.N)はS式である．この形のS式をドット対(<em>dotted pair</em>)という．
Mをcar部といい，Nをcdr部という．</li>
<li>M_1と，…と，M_nがS式ならば，(M_1…M_n)はS式である．この形のS式をリスト(<em>list</em>)という．</li>
<li>MがS式で，Cがマクロ文字ならば，CMはS式である．</li>
</ol>
<div class="highlight-scheme"><div class="highlight"><pre><span class="nv">x</span>           <span class="c1">; atomの例</span>
<span class="p">(</span><span class="nf">x</span> <span class="o">.</span> <span class="nv">x</span><span class="p">)</span>     <span class="c1">; dotted pairの例</span>
<span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>     <span class="c1">; listの例</span>
<span class="ss">&#39;x</span>          <span class="c1">; マクロ文字の例</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>原子<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>原子には，nil，シンボル，真偽値，数値，文字列などがある．
nilは()と書く．シンボルはたとえばlambdaと書く．真偽値は
#tおよび#fと書く．数値はたとえば42と書く．文字列はたとえば
&#8220;answer&#8221;と書く．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">()</span>          <span class="c1">; nil</span>
<span class="nv">x</span>           <span class="c1">; シンボル</span>
<span class="no">#f</span>          <span class="c1">; 真偽値</span>
<span class="mi">42</span>          <span class="c1">; 数値</span>
<span class="s">&quot;answer&quot;</span>    <span class="c1">; 文字列</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>リスト<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>簡単のため，(M_1…M_n)という形を(M_1.(….(M_n.())))の省略だという
ことにする．たとえば(x y z)は(x.(y.(z.())))の省略である．
(M_1…M_n)という形のS式をリストという．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>     <span class="c1">; リスト</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>マクロ文字<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>簡単のため，&#8217;Mという形を(quote M)の省略だということにする．
そのほかのマクロ文字は，(文字によって定義は異なるが，)
必ず，マクロ文字を使わない形のS式に変形できる．</p>
</div>
<div class="section" id="id10">
<h2>データ<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>原子はデータである．</li>
<li>ドット対はデータである．</li>
<li>手続きオブジェクトはデータである．</li>
<li>継続オブジェクトはデータである．</li>
<li>etc</li>
</ol>
</div>
<div class="section" id="id11">
<h2>S式はデータである<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>S式はデータである．S式が原子の形をしている場合は，データの定義によりS式はデータである．
S式がドット対の形をしている場合は，データの定義によりS式はデータである．
S式がリストの形をしている場合は，ドット対の省略形なのでS式はデータである．
S式がマクロ文字の形をしている場合は，マクロ文字を使わない形をしたS式の省略形なので
S式はデータである．以上ですべての場合は尽くされた．</p>
</div>
<div class="section" id="id12">
<h2>同図像性<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>LispプログラムはS式として書かれる．S式はデータなので，したがってLispプログラムは
データとして書かれる．このように，プログラムがデータとして書かれる言語は，同図像性を持つ
という．</p>
</div>
<div class="section" id="id13">
<h2>評価<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>あるデータVをLispプログラムとして実行し，VからあるデータWへと形が変わることを，V⟹Wと書き，
``VがWへと評価される&#8221;と読む．WをVの値という．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">42</span><span class="p">))</span> <span class="nv">x</span><span class="p">)</span>    <span class="c1">; ⟹ 42</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>評価規則<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>V⟹V (ただしMがシンボルを除く原子の場合)</li>
<li>x⟹V (ただしxがシンボルで，その評価時点で可視な束縛xにVが格納されている場合)</li>
<li>(quote V)⟹V</li>
<li>eval⟹FとなるFが存在し，V⟹Wならば(F V)⟹W．</li>
</ul>
</div>
<div class="section" id="id15">
<h2>原子の評価<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>シンボルを除き，原子は評価されるとそれ自身を返す．
M⟹M．ただしMはnil，真偽値，数値，文字列，関数オブジェクト，または継続オブジェクト．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">()</span>          <span class="c1">; ⟹ ()</span>
<span class="no">#f</span>          <span class="c1">; ⟹ #f</span>
<span class="mi">42</span>          <span class="c1">; ⟹ 42</span>
<span class="s">&quot;answer&quot;</span>    <span class="c1">; ⟹ &quot;answer&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>シンボルの評価<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>シンボルの評価には環境(<em>environment</em>)が必要である．その地点で有効な環境とは，
プログラムの中のある地点で有効なすべての可視な束縛からなる集合をいう．束縛とは，要するに，
ある記憶領域に束縛された変数のことである．たとえば，ある変数xとその変数に格納された値42
を(x:42)と書く．いま，有効な可視な束縛がそれしかないとすると，環境は{(x:42)}と書く．
{(x:42)}のもとで，x⟹42である．{}のもとで，x⟹エラーである．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="nv">x</span>           <span class="c1">; ⟹ v (ただし (x:v)∈環境)</span>
<span class="nv">x</span>           <span class="c1">; ⟹ エラー (ただし (x:v)∉環境)</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>リストの評価<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>リストの評価は，大きく分けて3種類ある．まず，特殊形式(<em>special form</em>)
と呼ばれるもので，これは，car部が，lambdaやletといったシンボルである場合に適用される．
次に，関数適用．これは，car部が，シンボルで，なおかつその名前の変数に手続きが束縛されている場合
に適用される．最後に，マクロ呼び出し．これは，car部が，マクロとして定義された名前である
場合に適用される．</p>
</div>
<div class="section" id="quote">
<h2>quote<a class="headerlink" href="#quote" title="Permalink to this headline">¶</a></h2>
<p>特殊形式quoteは，与えられた引数をそのまま返す．
(quote V) ⟹ V．Vが評価されないことに注意せよ．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="ss">&#39;x</span>          <span class="c1">; ⟹ x</span>
</pre></div>
</div>
</div>
<div class="section" id="lambda">
<h2>lambda<a class="headerlink" href="#lambda" title="Permalink to this headline">¶</a></h2>
<p>特殊形式lambdaは手続きオブジェクトをつくる．
(lambda (x_1…x_n) M)のように書く．
x_1…x_nはそれぞれ仮引数をあらわすシンボルである．
(lambda (x_1…x_n) M)⟹手続きオブジェクト．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>  <span class="c1">; ⟹ 手続きオブジェクト</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>関数適用<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>Vがマクロの名前でもなく特殊形式でもないならば，(V V_1…V_n)という形のリストは，評価されると関数適用とみなされる．
V_1…V_nを引数として，Vを呼び出すということである．V⟹WかつV_1⟹W_1かつ…V_n⟹W_nかつ
(W W_1…W_n)⟹Uならば(V V_1…V_n)⟹U．
V_k⟹W_kは引数はすべて評価されるということをあらわしている．
たとえば，(f x)の場合，V_1≡xだが，fにはxというシンボルが渡されるわけではなく，
x⟹WならばWが渡される．ここでは例を見て理解してほしい．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">42</span><span class="p">)</span>     <span class="c1">; ⟹ 42</span>
</pre></div>
</div>
</div>
<div class="section" id="eval">
<h2>eval<a class="headerlink" href="#eval" title="Permalink to this headline">¶</a></h2>
<p>quoteとは反対に，評価されないデータを評価する関数がevalである．
eval⟹FとなるFが存在し，V⟹Wならば(F V)⟹W．
評価されないS式は，通常は存在しないので，quoteしたものをeval関数に与えることになる．
通常，evalは引数として評価するS式を1つとるが，R7RSでは，evalは評価するS式と
環境の2つをとることに注意せよ．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;x</span> <span class="p">(</span><span class="nf">interaction-environment</span><span class="p">))</span>     <span class="c1">; = x</span>
<span class="c1">; (eval x) とすると，``x を評価したもの&quot;を評価してしまうので注意せよ．</span>
</pre></div>
</div>
</div>
<div class="section" id="cons">
<h2>cons<a class="headerlink" href="#cons" title="Permalink to this headline">¶</a></h2>
<p>ドット対は(M.N)のように書くが，ドット対をデータ(V.W)として扱うにはどうすれば
よいのだろうか．ひとつの案はquoteを使い(quote (x.y))のようにすることであるが，
これではxとyはシンボルであって変数ではない(評価されない)ことになってしまう．
評価したい場合はcons関数を使い，(cons x y)とする．
cons⟹FとなるFが存在し，(F V W)⟹(V.W)</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;x</span> <span class="ss">&#39;y</span><span class="p">)</span>     <span class="c1">; ⟹ (x.y)</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h2>バッククォートとカンマ<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>マクロ文字`とマクロ文字,は対応して使われる．
,は`のなかでしか使うことができない．
`Mの展開形を次のように帰納的に定義する:</p>
<ol class="arabic simple">
<li>Mが原子なら `M≡&#8217;M</li>
</ol>
<p>2. NがS式で，Mが,Nの形をしているなら `M≡N
2. Mが(N.R)の形をしているなら `M≡(cons `N `R)</p>
<p>たとえば `(x ,y z)≡`(x.(,y.(z.())))≡
(cons `x `(,y.(z.())))≡(cons &#8216;x (cons `,y `(z.())))≡
(cons &#8216;x (cons y (cons `z `())))≡(cons &#8216;x (cons y (cons &#8216;z &#8216;())))</p>
</div>
<div class="section" id="id20">
<h2>準備まとめ<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>空白，注釈は無視される</li>
<li>文法はS式．原子，ドット対，リスト，マクロ文字．</li>
<li>同図像性(S式はデータである)</li>
<li>評価規則．原子の評価，シンボルの評価，リストの評価．quote，lambda，eval，cons，
バッククォートとカンマ</li>
</ul>
</div>
<div class="section" id="id21">
<h2>マクロ<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<p>マクロとはLispのコードを返す関数である．マクロとはただの関数であると考えたほうがいい．
特殊な機能だと考えるのは混乱するだけである．
返すのがたまたまLispのコードであるというだけである．
たとえば，関数Fは，Lispのコードを受け取ってLispのコードを返す函数である．
であらば，(eval (F &#8216;M_1…&#8217;M_n))のように書けば，それはもはやマクロである．</p>
</div>
<div class="section" id="id22">
<h2>マクロ適用<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>とはいえ，いちいち戻り値であるLispのコードを評価するためにevalを書くのは面倒だし，
quoteを書くのもやはり面倒である．簡単のため，FがLispのコードを受け取って
Lispのコードを返す関数の名前だとすると，F*を次のように書けるということにする．
(eval (F &#8216;M_1…&#8217;M_n))≡(F* M_1…M_n)</p>
</div>
<div class="section" id="id23">
<h2>マクロ定義<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>特殊形式defmacroは，(defmacro x (y_1…y_n) M)のように書く．
xはマクロの名前をあらわすシンボルである．
y_1…y_nはそれぞれ仮引数をあらわすシンボルである．
MはS式である．</p>
</div>
<div class="section" id="id24">
<h2>例示は理解の試金石<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id25">
<h3>インクリメントを定義する<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>例はCommon Lispで書かれていることに注意せよ．</p>
<div class="highlight-lisp"><pre>(defmacro ++ (var) `(setf ,var (1+ ,var)))
(setq i 0)
(++ i)</pre>
</div>
</div>
<div class="section" id="id26">
<h3>簡約1<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>マクロは関数のｼﾝﾀｯｸｽｼｭｶﾞ-だと考える</p>
<div class="highlight-lisp"><pre>(defun ++ (var) `(setf ,var (1+ ,var)))
(setq i 0)
(eval (++ 'i))</pre>
</div>
</div>
<div class="section" id="id27">
<h3>簡約2<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>インライン展開してみる</p>
<div class="highlight-lisp"><pre>(setq i 0)
(eval '(setf i (1+ i)))</pre>
</div>
</div>
<div class="section" id="id28">
<h3>簡約3<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>evalとquoteをどちらもはずす</p>
<div class="highlight-lisp"><pre>(setq i 0)
(setf i (1+ i))</pre>
</div>
</div>
<div class="section" id="id29">
<h3>定義の解説1<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>`(setf ,var (1+ ,var)) は (cons &#8216;setf (cons var (cons (cons &#8216;1+ (cons var nil)) nil)))
と同じである．要は (setf <em>var</em> (+1 <em>var</em>)) という形のデータをつくるということである．
ただし <em>var</em> は引数に置換される．</p>
<div class="highlight-lisp"><pre>(defmacro ++ (var) `(setf ,var (1+ ,var)))</pre>
</div>
</div>
<div class="section" id="id30">
<h3>定義の解説2<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>もし++マクロが関数だとすると， (++ i) は (eval (++ &#8216;i)) のように理解するのがはやい．
つまり， ++ に &#8216;i を与えて，その戻り値 (setf i (1+ i)) を eval するということである．</p>
<div class="highlight-lisp"><pre>(setq i 0)
(++ i)</pre>
</div>
</div>
</div>
<div class="section" id="id31">
<h2>マクロと同図像性<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>Lispがマクロのような強力な機能をもつのは，ひとえに同図像性のおかげであろう．
つまり，Lispでは，Lispのソースコード自体を第一級の対象(データ)として扱えるのである．
Lispでは，ソースコードを，関数の引数として渡したり，戻り値として返したりできるのである．</p>
</div>
<div class="section" id="id32">
<h2>マクロとS式<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h2>
<p>しばしば，Lispのマクロが強力なのはS式のおかげだといわれるが，じっさいはそうではない．
S式は構文規則を定めるものであってデータではない．重要なのは同図像性であって，構文ではない．
どんな構文であろうと，けっきょくはそれがリストとして扱えるかどうかが重要なのだ．たとえば，
今回扱ったS式は一般的な定義を拡張してリストとマクロ文字を定義に含めた．
そのおかげで関数適用を(f.(x.(y.(z.()))))のように書かなくてよくなったし，
(quote x)を&#8217;xと書けるようになった．たとえば，加えて，中置記法{M :N R}は(N M R)の省略だ
ということにしても，マクロが強力なのは変わらない． <strong>S式は重要ではない</strong> ．</p>
</div>
<div class="section" id="id33">
<h2>各方言のマクロ<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
<p>いままでは，Lisp一般の話をしてきた．これからは各方言に搭載されている
マクロをザッと見ていく．</p>
<ol class="arabic simple">
<li>Common Lisp</li>
<li>Scheme</li>
<li>Clojure</li>
</ol>
</div>
<div class="section" id="common-lisp">
<h2>Common Lispのマクロ<a class="headerlink" href="#common-lisp" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>キーワード</li>
<li>不健全</li>
<li>gemsym</li>
<li>コンパイル時に評価される</li>
<li>再帰できない</li>
<li>リードマクロ</li>
</ol>
</div>
<div class="section" id="defmacro">
<h2>defmacro<a class="headerlink" href="#defmacro" title="Permalink to this headline">¶</a></h2>
<p>Common Lisp のマクロは， defmacro を使って書く．</p>
<div class="highlight-lisp"><pre>(defmacro ++ (var) `(setf ,var (1+ ,var)))
(setq i 0)
(++ i)  ; ⟹ 1</pre>
</div>
</div>
<div class="section" id="id34">
<h2>不健全<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id35">
<h3>後置デクリメント<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>Scheme にいわせれば， Common Lisp のマクロは不健全だという．
その理由は，変数に関する名前解決のルールにある．
たとえば，マクロ内である計算結果をもち回したいので，
一時的な変数にいれたいとする．そのため tmp と名付けることにする．</p>
<div class="highlight-lisp"><pre>(defmacro post++ (var)
  `(let ((tmp ,var))
    (setf ,var (1+ ,var))
    tmp))
(setq i 0)
(post++ i)  ; ⟹ 0</pre>
</div>
</div>
<div class="section" id="tmp">
<h3>tmpという変数名は？<a class="headerlink" href="#tmp" title="Permalink to this headline">¶</a></h3>
<p>しかし，運悪くtmpという名前の変数名を使っていると，結果が期待したものにはならない．</p>
<div class="highlight-lisp"><pre>(setq tmp 0)
(post++ tmp)  ; ⟹ 1</pre>
</div>
</div>
<div class="section" id="id36">
<h3>展開された形の比較<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<div class="highlight-lisp"><pre>(setq i 0)
(let ((tmp i))
  (setf i (1+ i))
  tmp) ; ⟹ 0
(setq tmp 0)
(let ((tmp tmp))
  (setf tmp (1+ tmp))
  tmp) ; ⟹ 1</pre>
</div>
</div>
</div>
<div class="section" id="gensym">
<h2>gensym<a class="headerlink" href="#gensym" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id37">
<h3>安全な後置デクリメント<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<p>不健全であると考えると，一時的な値をなにか変数にいれることができない
ように思える．なぜならば，どんな名前を選んでもそれが使われてしまってはバグが避けられない
からである．しかし，一時的な値に名前をつけることは必要であろう．
そこで， Common Lisp には gensym という関数がある．これは，プログラム内に登場する
いかなるシンボルともかぶらないシンボルを返すものである．</p>
<div class="highlight-lisp"><pre>(defmacro post++ (var)
  (let ((tmp (gensym)))
    `(let ((,tmp ,var))
      (setf ,var (1+ ,var))
      ,tmp)))
(setq tmp 0)
(post++ tmp)    ; ⟹ 0</pre>
</div>
</div>
<div class="section" id="id38">
<h3>gensym の返す値<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<div class="highlight-lisp"><pre>(gensym)    ; ⟹ #:G2814</pre>
</div>
</div>
<div class="section" id="id39">
<h3>展開された形<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h3>
<div class="highlight-lisp"><pre>(setq tmp 0)
(let ((G2814 tmp))
  (setf tmp (1+ tmp))
  G2814) ; ⟹ 0</pre>
</div>
</div>
<div class="section" id="id40">
<h3>運が悪かったら？<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<p>gensymが運悪く仕様済みのシンボルを返してしまったらバグるのでは？　という疑問を
感じるかもしれない．安心してほしい．それはない．</p>
</div>
</div>
<div class="section" id="id41">
<h2>コンパイル時に評価される<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<p>Common Lispのマクロはコンパイル時に評価される．
一部の方々は，この響きだけでゾクゾクと悦びを感じるのではなかろうか．
安心してほしい．もちろんコンパイル時計算もできる．レイトレーシングだって，おそらく
可能だろう．</p>
</div>
<div class="section" id="id42">
<h2>再帰できない<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h2>
<p>マクロがコンパイル時に評価されることのいちばんやっかいな点は再帰できないことである．
たとえば，次のようなマクロを(f 42)と呼び出すと停止しない．
ifが評価されるのは実行時で，fが評価されるのはコンパイル時だから，
(if t then (f …)) のようにしても， (f …) の評価は発生してしまうのである．ちなみに，
C++ の template でもよく似た問題が発生する．
さらにやっかいなことに，コンパイルせずインタプリタとして起動すると実行できてしまう．
インタプリタだと，(f …)の評価が発生しないからである．</p>
<div class="highlight-lisp"><pre>(defmacro f (x)
  `(if t ,x (f ,x)))</pre>
</div>
</div>
<div class="section" id="id43">
<h2>リードマクロ<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h2>
<p>マクロ文字&#8217;や`みたいなものをユーザが定義することもできる．
たとえば，1引数の関数を書くのにいちいちlambdaというキーワードや仮引数を書くのは
めんどうだから， %it というコードをみつけたら (lambda (it) it) のように展開してくれたら便利
かもしれない．</p>
<div class="highlight-lisp"><pre>(set-macro-character #\%
  #'(lambda (stream char)
    (list 'lambda '(it) (read stream t nil t))))
(funcall %it 42) ; ⟹ 42</pre>
</div>
</div>
<div class="section" id="scheme">
<h2>Schemeのマクロ<a class="headerlink" href="#scheme" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>define-syntaxとsyntax-rules</li>
<li>健全</li>
<li>syntax-case</li>
<li>新しい束縛は追加できない</li>
</ol>
</div>
<div class="section" id="define-syntaxsyntax-rules">
<h2>define-syntaxとsyntax-rules<a class="headerlink" href="#define-syntaxsyntax-rules" title="Permalink to this headline">¶</a></h2>
<p>Scheme のマクロは， define-syntax と syntax-rules を使う</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="k">define-syntax </span><span class="nv">++</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">(</span> <span class="p">(</span><span class="nf">++</span> <span class="nv">var</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">var</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">var</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">++</span> <span class="nv">i</span><span class="p">)</span> <span class="c1">; ⟹ 1</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h2>健全<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h2>
<p>Common Lispのマクロと違い，Schemeのマクロは，マクロが返すリストが
新しい束縛をつくる場合は，自動で安全な名前にリネームされる．
たとえば，この例のtmpは，じっさいにはtmpではなく，なにかユーザが使わないような
名前になっている．</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="k">define-syntax </span><span class="nv">post++</span>
  <span class="p">(</span><span class="k">syntax-rules </span><span class="p">()</span>
    <span class="p">(</span> <span class="p">(</span><span class="nf">++</span> <span class="nv">var</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">tmp</span> <span class="nv">var</span><span class="p">))</span>
        <span class="p">(</span><span class="k">set! </span><span class="nv">var</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">var</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nv">tmp</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">tmp</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">post++</span> <span class="nv">tmp</span><span class="p">)</span> <span class="c1">; ⟹ 0</span>
</pre></div>
</div>
</div>
<div class="section" id="syntax-case">
<h2>syntax-case<a class="headerlink" href="#syntax-case" title="Permalink to this headline">¶</a></h2>
<p>R6RS では syntax-case というキーワードもあったけど，R7RSではなくなっている．
R6RSは扱わないので，触れるだけにする．</p>
</div>
<div class="section" id="id45">
<h2>新しい束縛は追加できない<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h2>
<p>前の前の節で，(let ((tmp …))…)のようにしても変数名がリネームされると
言ったけど，逆に，tmpをローカル変数として追加したりすることはできない．</p>
</div>
<div class="section" id="clojure">
<h2>Clojureのマクロ<a class="headerlink" href="#clojure" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>defmacro</li>
</ol>
<p>2. 変数補足は発生しない
2. auto-gensym
3. 変数補足を利用できる
4. ディスパッチマクロ</p>
</div>
<div class="section" id="id46">
<h2>defmacro<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
<p>Clojure のマクロは， defmacro を使って書く．
ちなみに Clojure は変数の再代入を許していないので，インクリメントを
ただ値を返すだけにする．これではインクリメントである意味がないけど，
例なので許してほしい．また， Clojure ではマクロ文字,の代わりに
マクロ文字~を使う．</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">++</span> <span class="p">[</span><span class="nv">var</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nb">+ </span><span class="o">~</span><span class="k">var </span><span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">++</span> <span class="nv">i</span><span class="p">)</span>  <span class="c1">; ⟹ 1</span>
</pre></div>
</div>
</div>
<div class="section" id="id47">
<h2>変数補足は発生しない<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h2>
<p>たとえば次のように書くと，危険だということでコンパイルエラーになる．
リネームされるというわけではないけど，思わぬバグは発生しにくくなっている．</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">post++</span> <span class="p">[</span><span class="nv">var</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tmp</span> <span class="o">~</span><span class="nv">var</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="o">~</span><span class="k">var </span><span class="mi">1</span><span class="p">)</span>
    <span class="nv">tmp</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">tmp</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">post++</span> <span class="nv">tmp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="auto-gensym">
<h2>auto-gensym<a class="headerlink" href="#auto-gensym" title="Permalink to this headline">¶</a></h2>
<p>変数名のあとに # を書くと， gensym で置き換えられる</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">post++</span> <span class="p">[</span><span class="nv">var</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tmp#</span> <span class="o">~</span><span class="nv">var</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="o">~</span><span class="k">var </span><span class="mi">1</span><span class="p">)</span>
    <span class="nv">tmp#</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">tmp</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">post++</span> <span class="nv">tmp</span><span class="p">)</span>  <span class="c1">; ⟹ 0</span>
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h2>変数補足を利用できる<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>アナフォリックマクロみたいなものを書きたい場合，シンボルに ~&#8217; とつける．
これはマクロ文字~とマクロ文字&#8217;の組み合わせではなく，独立したマクロ文字であることに注意</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">aif</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">~</span><span class="ss">&#39;it</span> <span class="o">~</span><span class="nv">x</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="o">~</span><span class="ss">&#39;it</span> <span class="o">~</span><span class="nv">y</span> <span class="o">~</span><span class="nv">z</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">aif</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">it</span> <span class="nv">nil</span><span class="p">)</span>   <span class="c1">; ⟹ &#39;(x y z)</span>
</pre></div>
</div>
</div>
<div class="section" id="id49">
<h2>ディスパッチマクロ<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
<p>リードマクロに似たディスパッチマクロというものがある．
これは必ず # から始める必要があるけど基本的にはリードマクロと同じようなものである．</p>
</div>
<div class="section" id="id50">
<h2>マクロの利用例<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
<p>マクロの利用例を紹介する．</p>
<ol class="arabic simple">
<li>構文をつくる</li>
<li>コンテキストをつくる</li>
<li>毎回入力するのが面倒なものを省略する</li>
<li>コンパイル時計算</li>
<li>アナフォリックマクロ</li>
<li>言語をつくる</li>
</ol>
</div>
<div class="section" id="id51">
<h2>構文をつくる<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
<p>おそらくいちばん頻度の高い利用方法がこれで，一般的なLisp方言は，
過半数の構文をライブラリとして実装している．
たとえば，Clojureにはdefとfnという構文がある．(def x y)は，yという値にxという名前をつける．
一方，fnは(fn [x] x)のように書いて無名関数をつくる．すると自然に，関数に名前をつける場合は，
(def f (fn [x] x))のように書くことになる．しかし，このようなコードは頻出する．
あるいは，defのほうかに，関数をつくる構文があると便利かもしれない．そういう場合，マクロを
使って，defnをdefとfnを組み合わせたものとして定義できる．</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defmacro </span><span class="nv">our-defn</span> <span class="p">[</span><span class="nb">name </span><span class="o">&amp;</span> <span class="nv">spec</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">def </span><span class="o">~</span><span class="nb">name </span><span class="p">(</span><span class="k">fn </span><span class="o">~@</span><span class="nv">spec</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">our-defn</span> <span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id52">
<h2>コンテキストをつくる<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h2>
<p>次に利用する頻度が高いのがたぶんこれであろう．
たとえば，letは新しいコンテキストをつくってローカル変数を導入する．
しかし，もしかしたら，ユーザが新しいローカル変数を導入する構文を
つくりたいかもしれない．例としてはforeachなどがある．
foreachは (foreach item iter body)のように書くとitemをローカル変数として導入したい．
そういう場合，マクロを使えば実現できるだろう．</p>
</div>
<div class="section" id="id53">
<h2>省略する<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h2>
<p>プログラムを書いているとき，あなたはおそらく毎回同じようなコードを書くことに
悩まされるはずである．それがある種のルーチンに分離できるものであればいいが，
現実はそうはいかない．たとえば，JavaScriptを書いていて，functionと毎回書くのが面倒だと
いうのは誰もが感じることだろう．そういう場合，マクロを使えば，functionの代わりに
fnというキーワードに変更できる．たとえば，Common Lispではlambdaというキーワードがあるけど，
lambdaは長すぎるからlaにしたいとしよう．それもマクロなら簡単に実現できる．</p>
<div class="highlight-lisp"><pre>(defmacro la (x y)
  `(lambda ,x ,y))
(la (x) x) ; ⟹ #&lt;FUNCTION :LAMBDA (X) X&gt;</pre>
</div>
</div>
<div class="section" id="id54">
<h2>コンパイル時計算<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h2>
<p>ふつうの実装では，マクロの展開はコンパイル時におこなう．
マクロは実行時と同じだけの計算できる．したがって，マクロでコンパイル時計算をおこなうことも
もちろん可能だ．ほとんどのケースでは必要ないだろうが，
もしかしたら，コンパイル時に，定数を計算して定数に展開したいことがあるかも
しれない．そういう場合，マクロを使うと言う選択肢もある．</p>
</div>
<div class="section" id="id55">
<h2>アナフォリックマクロ<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h2>
<p>たとえば， if の条件式で評価された価を then 節で使いたいとか，
while の条件式で評価された価を本体で使いたいということはよくあることだ．
if it = expr…のようにして変数を書く手もあるが，よくあるケースなので it を省略できるように
しておけば便利そうである．マクロは新しい変数が存在するように展開することもできるので，
このようなものも実装できる．</p>
</div>
<div class="section" id="id56">
<h2>言語をつくる<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h2>
<p>そう，Lispの本当の力…それは，その言語自体をその言語言語で拡張できることだ．
構文やコンテキストなんてものはささやかなものだ．本当の力は，S式で書かれたまったく別の言語を見たとき
完全に理解できる．普通の人は，型システムをマクロで実装しようなんて思わないだろう．
しかし，条件さえ整えば，動的言語であるLispに強力な型システムを積むことすらできる．
ほかの言語のように，値の型がまちがっていたらエラーにするなんていう動的検査ではない．
本当に静的な検査をやってのけてしまうのだ．実例は， Clojure では core.typed，
Scheme では typed/racket などがある．興味があれば，調べてみてほしい．</p>
</div>
<div class="section" id="id57">
<h2>終わりに<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h2>
<p>いかがだっただろうか．Lispのマクロの力をすこしは感じ取って頂けたのではないだろうか．
ともあれここまで読んでくれてありがとう! もしあなたにその気があれば，ぜひ
Lispのうえに(<em>on lisp</em>)静的型付き言語を実装してみてほしい．そして高らかにLispを
disるのだ!</p>
</div>
</div>


    </div>

</body>
</html>