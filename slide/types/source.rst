静的型付き言語への誘い
================================================================================

概要
--------------------------------------------------------------------------------

諸君，わたしは静的型が好きだ

諸君，わたしは静的型が大好きだ

* 単純型が好きだ
* 関数型が好きだ
* バリアントが好きだ
* 部分型が好きだ
* 公称型が好きだ
* 構造型が好きだ
* 再帰型が好きだ
* 全称型が好きだ
* 型再構築が好きだ

静的におこなわれるありとあらゆる型付けが大好きだ

基本型
--------------------------------------------------------------------------------

どんな言語にもintとかstringだとかいう構造をもたない単純な値の集合を表す型がある．
そういった型のことを基本型という．
型付け規則は簡単で，たとえば，42ならば即座にintであるとわかる．
"answer"ならば即座にstringである．

.. code-block:: ocaml

   42           (* int *)
   "answer"     (* string *)

関数型
--------------------------------------------------------------------------------

はたしてラムダにはいかなる型がつくのだろうか？　ラムダに型をつける型がある．
それを関数型(*arrow type*)という．引数の型をT，戻り値の方をUとすると，T→Uと書く．

.. code-block:: ocaml

   fun (x : int) -> x   (* int→int *)

直積型
--------------------------------------------------------------------------------

たとえば，人をあらわすデータは名前と年齢からなる．すると，自然に，
多くの関数は名前と年齢を引数にとって処理をしそうである．しかし，いまある規則だけでは
いつも別々の引数として渡さなければならない．そういう場合，2種類の型を複合的にあらわす
型があったら便利そうである．直積型(*product type*)はT×Uと書く．値の組を(x,y)と書く．
この型をもつ値は，T型の値とU型の値の2つの値をもつ．いわゆるタプルというやつである．
それぞれの値は，fst:T×U→T関数とsnd:T×U→U関数でとりだすことができる．

.. code-block:: ocaml

   let t    = ("boxp", 20)     (* (string * int) *)
   let name = fst t
   let age  = snd t

レコード
--------------------------------------------------------------------------------

直積型は，たしかに複数の型の値をまとめて扱えるが，メンバがたくさん増えてくると
たいへんそうである．たとえば(T_1×T_2×…×T_n)と書くと，T_nを取り出すのに
sndをn-1回適用しないといけないので使いにくそうである．T_nにラベルをつけて，
1回の操作で取り出せるようにすると便利そうである．そのような型をレコード(*record*)という．

.. code-block:: ocaml

    type person = {
      name : string;
      age : int;
    }
    let p       = { name = "haru"; age = 20 }
    let name    = p.name
    let age     = p.age


バリアント(直和型)
--------------------------------------------------------------------------------

直積型とは逆に，たとえばintかstringかどちらかという型もあれば便利そうである．
そのような型をバリアント(*variant*)という．
しかし，取り出す場合は，たとえばintを取り出そうとしてもないかもしれないし，
その逆もそうなので，分岐する必要がある．

.. code-block:: ocaml

   type t = X of int 
          | Y of string

   let t1 = X 42        (* t *)
   let t2 = Y "answer"  (* t *)
   let f t = match t with
     | X i -> print_string "X = "; print_int i; print_newline ()
     | Y s -> print_string "Y = "; print_endline s

部分型
--------------------------------------------------------------------------------

たとえばレコード型{x:T}と{x:T,y:U}と関数f:{x:T}→Tについて考える．
fが必要としているのは字面だけ見れば{x:T}のxだけであって，yはあろうと
なかろうと問題ないはずである．しかし{x:T}≠{x:T,y:U}なので，
{x:T,y:U}の値をfに渡すことはできない．これは直観に反する．
{x:T,y:U}を{x:T}としてfに渡せたら便利そうである．そのような型付けを部分型(*subtyping*)
といい，S<:Tと書く．例では{x:T,y:U}<:{x:T}である．オブジェクト指向言語でいう
継承は部分型のひとつで，サブクラス<:スーパークラスである．

公称的部分型
--------------------------------------------------------------------------------

明示的に宣言された関係のみを部分型とみなす型付けを公称的部分型(*nominal subtyping*)
という．オブジェクト指向の継承はextendsだとか<だとかいう記号を使って明示的に書くので
公称的部分型である．


構造的部分型
--------------------------------------------------------------------------------

部分型関係を宣言せずとも，構造的に部分型とみなせるならば部分型とみなす型付けを
構造的部分型(*structural subtyping*)という．
最近は採用している言語も増えているようである．

再帰型
--------------------------------------------------------------------------------

型はふつう再帰できない．再帰的な型をあらわすのが
再帰型である．再帰型はμx.Tと書く．T内に出現するxをμx.T→xで置き換えたように
型付けされる．たとえばμx.T→xは，T→T→…→μx.T→xのような型になる．
どんなにTを与えても毎回同じ関数を返す．

.. code-block:: ocaml

   let rec f x = f      (* int -> 'a as 'a *)
   let _ = f 1 2 3 4

全称型
--------------------------------------------------------------------------------

関数によっては，intをもらってもstringをもらっても同様に機能してほしいことがある．
関数だけでなくデータ構造もそうである．たとえば，リストは，intのリストもstringのリストも
同じようにリストであり，内容物はなんでもよいといった場合である．
そのような関数やデータ構造をあらわす型が全称型である．全称型は，
∀x.Tのように書く．たとえば，∀x.x→xは，int→intでもstring→stringでもどちらでも
機能する関数という意味である．

型再構築
--------------------------------------------------------------------------------

関数の引数の型や戻り値の型をいちいち書くのはめんどうである．
関数は論理的な構造をもつのだから，機械的に，関数の型を演繹してみようと考えるのは
自然な発想であろう．そのような機構を型再構築(*type reconstruction*)だとか
型推論(*type inference*)だとかいう．ツイのオタクは後者で聞き慣れているであろう．
たとえば，λx.x+1は，xの型を明示していないが，x+1という使われ方をしているから
明らかにx:intである．また，戻り値はintである．このように，引数の型を，本体内での使われ方から
推論するのである．
