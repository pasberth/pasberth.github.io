<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>静的型付き言語への誘い</title>

<meta name="description" content="静的型付き言語への誘い">    


<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/simple.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + 
    '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>静的型付き言語への誘い</h1>

<p>
<h4></h4>
</p>
</section>  


<section id="概要" class="level1">
<h1>概要</h1>
<p>諸君，わたしは静的型が好きだ</p>
<p>諸君，わたしは静的型が大好きだ</p>
<ul>
<li>単純型が好きだ</li>
<li>関数型が好きだ</li>
<li>バリアントが好きだ</li>
<li>部分型が好きだ</li>
<li>公称型が好きだ</li>
<li>構造型が好きだ</li>
<li>再帰型が好きだ</li>
<li>全称型が好きだ</li>
<li>型再構築が好きだ</li>
</ul>
<p>静的におこなわれるありとあらゆる型付けが大好きだ</p>
</section>
<section id="基本型" class="level1">
<h1>基本型</h1>
<p>どんな言語にもintとかstringだとかいう構造をもたない単純な値の集合を表す型がある． そういった型のことを基本型という． 型付け規則は簡単で，たとえば，42ならば即座にintであるとわかる． &quot;answer&quot;ならば即座にstringである．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">42           <span class="co">(* int *)</span>
<span class="st">&quot;answer&quot;</span>     <span class="co">(* string *)</span></code></pre>
</section>
<section id="関数型" class="level1">
<h1>関数型</h1>
<p>はたしてラムダにはいかなる型がつくのだろうか？　ラムダに型をつける型がある． それを関数型(<em>arrow type</em>)という．引数の型をT，戻り値の方をUとすると，T→Uと書く．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">fun</span> (x : <span class="dt">int</span>) -&gt; x   <span class="co">(* int→int *)</span></code></pre>
</section>
<section id="直積型" class="level1">
<h1>直積型</h1>
<p>たとえば，人をあらわすデータは名前と年齢からなる．すると，自然に， 多くの関数は名前と年齢を引数にとって処理をしそうである．しかし，いまある規則だけでは いつも別々の引数として渡さなければならない．そういう場合，2種類の型を複合的にあらわす 型があったら便利そうである．直積型(<em>product type</em>)はT×Uと書く．値の組を(x,y)と書く． この型をもつ値は，T型の値とU型の値の2つの値をもつ．いわゆるタプルというやつである． それぞれの値は，fst:T×U→T関数とsnd:T×U→U関数でとりだすことができる．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> t    = (<span class="st">&quot;boxp&quot;</span>, 20)     <span class="co">(* (string * int) *)</span>
<span class="kw">let</span> name = fst t
<span class="kw">let</span> age  = snd t</code></pre>
</section>
<section id="レコード" class="level1">
<h1>レコード</h1>
<p>直積型は，たしかに複数の型の値をまとめて扱えるが，メンバがたくさん増えてくると たいへんそうである．たとえば(T_1×T_2×…×T_n)と書くと，T_nを取り出すのに sndをn-1回適用しないといけないので使いにくそうである．T_nにラベルをつけて， 1回の操作で取り出せるようにすると便利そうである．そのような型をレコード(<em>record</em>)という．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> person = {
  name : <span class="dt">string</span>;
  age : <span class="dt">int</span>;
}
<span class="kw">let</span> p       = { name = <span class="st">&quot;haru&quot;</span>; age = 20 }
<span class="kw">let</span> name    = p.name
<span class="kw">let</span> age     = p.age</code></pre>
</section>
<section id="バリアント直和型" class="level1">
<h1>バリアント(直和型)</h1>
<p>直積型とは逆に，たとえばintかstringかどちらかという型もあれば便利そうである． そのような型をバリアント(<em>variant</em>)という． しかし，取り出す場合は，たとえばintを取り出そうとしてもないかもしれないし， その逆もそうなので，分岐する必要がある．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> t = <span class="dt">X</span> <span class="kw">of</span> <span class="dt">int</span> 
       | <span class="dt">Y</span> <span class="kw">of</span> <span class="dt">string</span>

<span class="kw">let</span> t1 = <span class="dt">X</span> 42        <span class="co">(* t *)</span>
<span class="kw">let</span> t2 = <span class="dt">Y</span> <span class="st">&quot;answer&quot;</span>  <span class="co">(* t *)</span>
<span class="kw">let</span> f t = <span class="kw">match</span> t <span class="kw">with</span>
  | <span class="dt">X</span> i -&gt; print_string <span class="st">&quot;X = &quot;</span>; print_int i; print_newline ()
  | <span class="dt">Y</span> s -&gt; print_string <span class="st">&quot;Y = &quot;</span>; print_endline s</code></pre>
</section>
<section id="部分型" class="level1">
<h1>部分型</h1>
<p>たとえばレコード型{x:T}と{x:T,y:U}と関数f:{x:T}→Tについて考える． fが必要としているのは字面だけ見れば{x:T}のxだけであって，yはあろうと なかろうと問題ないはずである．しかし{x:T}≠{x:T,y:U}なので， {x:T,y:U}の値をfに渡すことはできない．これは直観に反する． {x:T,y:U}を{x:T}としてfに渡せたら便利そうである．そのような型付けを部分型(<em>subtyping</em>) といい，S&lt;:Tと書く．例では{x:T,y:U}&lt;:{x:T}である．オブジェクト指向言語でいう 継承は部分型のひとつで，サブクラス&lt;:スーパークラスである．</p>
</section>
<section id="公称的部分型" class="level1">
<h1>公称的部分型</h1>
<p>明示的に宣言された関係のみを部分型とみなす型付けを公称的部分型(<em>nominal subtyping</em>) という．オブジェクト指向の継承はextendsだとか&lt;だとかいう記号を使って明示的に書くので 公称的部分型である．</p>
</section>
<section id="構造的部分型" class="level1">
<h1>構造的部分型</h1>
<p>部分型関係を宣言せずとも，構造的に部分型とみなせるならば部分型とみなす型付けを 構造的部分型(<em>structural subtyping</em>)という． 最近は採用している言語も増えているようである．</p>
</section>
<section id="再帰型" class="level1">
<h1>再帰型</h1>
<p>型はふつう再帰できない．再帰的な型をあらわすのが 再帰型である．再帰型はμx.Tと書く．T内に出現するxをμx.T→xで置き換えたように 型付けされる．たとえばμx.T→xは，T→T→…→μx.T→xのような型になる． どんなにTを与えても毎回同じ関数を返す．</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> f x = f      <span class="co">(* int -&gt; &#39;a as &#39;a *)</span>
<span class="kw">let</span> _ = f 1 2 3 4</code></pre>
</section>
<section id="全称型" class="level1">
<h1>全称型</h1>
<p>関数によっては，intをもらってもstringをもらっても同様に機能してほしいことがある． 関数だけでなくデータ構造もそうである．たとえば，リストは，intのリストもstringのリストも 同じようにリストであり，内容物はなんでもよいといった場合である． そのような関数やデータ構造をあらわす型が全称型である．全称型は， ∀x.Tのように書く．たとえば，∀x.x→xは，int→intでもstring→stringでもどちらでも 機能する関数という意味である．</p>
</section>
<section id="型再構築" class="level1">
<h1>型再構築</h1>
<p>関数の引数の型や戻り値の型をいちいち書くのはめんどうである． 関数は論理的な構造をもつのだから，機械的に，関数の型を演繹してみようと考えるのは 自然な発想であろう．そのような機構を型再構築(<em>type reconstruction</em>)だとか 型推論(<em>type inference</em>)だとかいう．ツイのオタクは後者で聞き慣れているであろう． たとえば，λx.x+1は，xの型を明示していないが，x+1という使われ方をしているから 明らかにx:intである．また，戻り値はintである．このように，引数の型を，本体内での使われ方から 推論するのである．</p>
</section>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,

  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'simple', 
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'default',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });

</script>

</body>
</html>
