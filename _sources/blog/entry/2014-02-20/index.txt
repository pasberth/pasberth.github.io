余帰納型
================================================================================

帰納型(Inductive type) というものがあるが、
余帰納型(CoInductive type) というものもあるらしい。
正直、帰納型も、余帰納型も、あまりよく理解できていないので、
ブログにするのは躊躇っていたのだけど、余帰納型という言葉を知らない人もいるだろうから、
ひとまず今のぼくの理解をブログにしておく。

数学で帰納法を習うだろうけども、帰納型というのは
そういう意味で帰納的な型なのだ。
Coq を勉強した方なら、たぶん一度は使ったことはあると思う、
Inductive で宣言するアレだ。

簡単にいえば、帰納というのは、 Haskell の data で
宣言するようなものに近いといえる。 Haskell では、たとえばリストを、

.. code-block:: haskell

    data List a = Nil | Cons a (List a)

のようにして宣言できる。これは、

1. nil はリストである
2. l がリストならば、 cons x l はリストである

というような定義をしている。

このように、帰納的な定義をするから
帰納型というわけだ。

なんだ、簡単じゃんと思うなかれ。
data と、Coq などの帰納型で重要な違いがひとつある。
それは、帰納型においては、無限の構造(たとえば無限リスト)
をつくることは許されないということだ。つまり、有限の長さを
持たないとコンパイラに弾かれるというわけだ。

どうして弾かれるのかというと、無限の構造というのは、
Haskell なら遅延評価だからたまたま停止するが、
けっきょくのところ、停止する保証がない構造だから。
無限リストを許してしまうと、たとえば、
map 関数にリストを渡したとして、この map 関数が無限に
再帰しないで停止する保証は、すくなくとも型の情報には含まれていない。

しかし、無限リストはたぶん便利だろう。
そこで、帰納型ではない方法で、無限の構造を定義できたら便利だ。

そういうときに、余帰納型を使う。
余帰納型は、無限の構造に型付けする型で、
余帰納型を使えば、無限の構造を扱っても必ず停止することが保証できる。

Haskeller は、たぶん Ruby とかの動的言語や、 Java のような
静的型付き言語に対して、「どうして
型で区別しないのだろう？」と思うことがしばしばあるだろう。
たとえば、  println みたいな入出力をともなう関数に、 IO で
タグ付けしないのは、 Haskeller からすればとても不自然だ。
Haskeller は、純粋な関数と、 IO をともなう関数を型で区別したがる。
それは大事なことだ。同じように、もっと強力な型システムを持つ言語
(Coqなど)から見ると、 Haskell の型はだいぶゆるい。どうして有限リストと
無限リストを型で区別しないのだろう？　どうして再帰をともなう関数と
そうでない関数を型で区別しないのだろう？　…など。
帰納型と余帰納型はそういうふうに、有限の構造と無限の構造を型レベルで
区別できるものだ(と思う)。