継続の実装について
================================================================================

たとえば．

.. code-block:: scheme

   (define cont #f)
   (define (f x) (call/cc (lambda (k) (set! cont k) x)))
   (+ (f 1) 42)     ; => (+ 1 42) => 43 
   (cont 2)         ; => (+ 2 42) => 44
   (cont 3)         ; => (+ 3 42) => 45

こんな感じの継続がある．この継続をどう実装すればよいか．

まず，最初の ``(+ (f 1) 42)`` に関して．ここで ``(f 1)`` を呼んだとき，コールスタックは
こんな感じになっているはずだ:

.. code::

   [
     {
       stack: 42;
       code: +の実行;
     }
   ]

そこで，これを丸ごとヒープにコピーする．これで継続オブジェクトkがつくれた．
kは， (k x) のようにして呼ぶと，さきほどコピーしたコールスタックをガンガンコールスタックに積む．
それから，もう一度，あたかも f が x を戻したかのように振る舞う．
``(call/cc proc)`` 自体は，kを引数にprocを呼び出し，そのまま実行する．戻り値はそのまま戻る．
結果として， ``(+ (f 1) 42)`` は 43 に評価される．
しかし，procはkをcontに割り当てているので，あとから呼び出すことができる．すると，
``(cont 2)`` は，あたかも ``(+ 2 42)`` を評価したかのように振る舞う．
``(cont 3)`` も同じだ．

参考: `Scheme/継続の種類と利用例 <http://ja.wikibooks.org/wiki/Scheme/%E7%B6%99%E7%B6%9A%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%81%A8%E5%88%A9%E7%94%A8%E4%BE%8B#.E5.AE.9F.E8.A3.85.E4.BE.8B>`_