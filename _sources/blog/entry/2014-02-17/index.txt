λρ-計算とcall/ccの型付け
================================================================================

読者はもちろん λ-計算くらい完全に理解されていると思う．
λ-計算は万人の教養であるが， λρ-計算は聞き慣れないであろう．
ぼくも昨日知ったばかりである．ちょっと勉強したところ，たいへん面白そうであるので，
ブログにしておこうと思う．

`λρ-calculus <http://komoriyuichi.web.fc2.com/symposium/lambda-rho5.pdf>`_
を読んだ．定義や，証明などはこの paper を参照してもらうことにして，
ここでは，例をつらつら書いてみる．

型なしλρ-項および型付きλρ-項の定義は， Definition 1.1 と
Definition 2.1 をそれぞれ参照してほしい．

次の記号は，型なしλρ-項の例である．

λxa.x(λy.ay)

また，型付きλρ-項としては次のように書く．

λxa.x(λy.(ay)^β):((α→β)→α)→α

ここで， x, y はλ-変数であり， a は ρ-変数 だ．
x がλ-変数で M がλρ-項ならぱ， (λx.M) という形のλρ-項を
λ-抽象といい， a がρ-変数で M がλρ-項ならぱ， (λa.M) という形のλρ-項を
ρ-抽象という，
ちなみに，この項に付けられた型は Peirce の法則という．

a が ρ-変数で M が λρ-項ならば (aM) という形のλρ-項を absurd という [#]_ ．
λxa.x(λy.ay) における (ay) の部分のことだ．

(ay)^β における ^β は型注釈で， ay が β という型を持つことを明示している．
absurd は不思議な型を持つ． a がρ-変数で，M がλρ-項で， a : Τ であり， M : Τ ならば， (aM)^σ : σ
である．この規則からすぐに， (aM) が任意の型を持つことがわかる．

部分項の型は，それぞれ，

* x : (α→β)→α
* y : α
* a : α
* (ay)^β : β
* (λy.(ay)^β) : α→β

こんな感じになってる．
x の型が謎だ．一体全体，こんな型を持つ関数が存在するのか？
Haskell には fix (Yコンビネータ) くらいしかないと思う…

簡約の定義によれば， absurd はおかしな簡約のされ方をする．
a がρ-変数ならば， ((a M)^σ→Τ)N は (a M)^Τ に簡約される．
absurd は任意の型を持つので，たとえば α→β→γ→…→Τ と延々続く
型を持つこともできる．すると，

* ((a M)^α→β→γ→δ→Τ N M P Q)
* → ((a M)^β→γ→δ→Τ M P Q)
* → ((a M)^γ→δ→Τ P Q)
* → ((a M)^δ→Τ Q)
* → (a M)^Τ

こんな感じに簡約されそうだ．

だから， ρ-変数 を引数に適用すると，
ひとつめの引数がずっと保存されて，
残りの引数はすべて捨てられてしまうわけだ．

それから，ρ-抽象を引数に適用すると，面白い動きをする．

a が ρ-変数ならぱ， (λa.M)N は λb.([λx.b(xN)/a]M)N に簡約される．
なにやら複雑であるが，これはρ-変数に対する代入だ．
通常のλ-抽象の代入と同じように，展開してみると，
「ρ-変数に与えられた引数を持ち上げて，それにNが与えられる」みたいな感じの
動きをする．たとえば，

(λa.aMN)R

という形を考えてみる．これは，

* (λa.aMN)R
* → λb.([λx.b(xN)/a](aMN))R
* ≡ λb.((λx.b(xR))MN)R
* → λb.(([M/x]b(xR))N)R
* ≡ λb.b(MR)NR
* → λb.b(MR)R
* → λb.b(MR)

こんな感じに簡約される．

言葉で説明するのは，なかなか難しいのだけど，
とにかく， (λa.aMN)R のような形だと，最初に a に与えられた値が飛ぶように
λa. の場所まで戻ってしまう．それ以外の値は，すべて無視される．

なんとなく，似たものをわれわれは知っている．
そう， Scheme の call/cc である．

* ρ-変数は第一級継続に，
* ρ-抽象 λa.M は (call/cc (lambda (a) M)) に，

それぞれ似ている．じっさいに，さっきの項を，継続として書いてみると，

.. code-block:: scheme

    ((call/cc (lambda (a) ((a M) N))) R)

こんな感じになるだろう．

この Scheme のコードは，実際に， N を無視して，
M を call/cc の外側まで飛ばす．そして， (M R) が実行される．

さて，では， ρ-抽象が call/cc だというなら， Peirce の法則の証明である
λxa.x(λy.(ay)^β):((α→β)→α)→α も Scheme で書けそうである．愚直に翻訳すると，

.. code-block:: scheme

    (lambda (x) (call/cc (lambda (a) (x (lambda (y) (a y))))))

となる．

このコードになにか意味があるとは思えないけども，
λρ-計算で型がつけられるのだから， Scheme でも型がつけられそうである．
部分項の型を列挙すると，

* x : (α→β)→α
* y : α
* a : α
* (a y) : β
* (lambda (y) (a y)) : α→β
* (x (lambda (y) (a y))) : β
* (lambda (a) (x (lambda (y) (a y)))) : α→β
* (call/cc (lambda (a) (x (lambda (y) (a y))))) : β

こんな感じになる． call/cc も関数だから，たぶん，引数である 
(lambda (a) (x (lambda (y) (a y)))) : α→β の型を仮定した型になるだろう．
つまり，

* call/cc : (α→β)→β

になるんだと思う…(自信なさげ)

と，ここまで書いたわけであるが，
`型付き対称λ計算と古典論理 <http://pllab.is.ocha.ac.jp/~asai/jpapers/ppl/ueda10.pdf>`_
という文献や， `A Formulae-as-Types Notion of Control <http://www.cl.cam.ac.uk/~tgg22/publications/popl90.pdf>`_
という文献を見つけた．たぶんこれを読んだほうがいいのだろう…

参考文献
--------------------------------------------------------------------------------

* `λρ-calculus <http://komoriyuichi.web.fc2.com/symposium/lambda-rho5.pdf>`_

.. [#] absurd の訳語をぼくは知らないのです．へたな用語の発明は避けたいので，そのまま書くこととします．詳しい人教えてください．
