<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
      <title>部分型</title>
    

    <link rel="stylesheet" type="text/css" href="../../../_static/main.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
</head>
<body>

    <div class="body">
        
  <div class="section" id="id1">
<h1>部分型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>ほとんどのプログラミング言語にはレコード型というものが存在する．
複数の機能を持つ型の機能のひとつとして
使えるというものもある．たとえば Haskell では直和型と同じ構文で宣言できる
( <tt class="code highlight haskell docutils literal"><span class="keyword reserved"><span class="pre">data</span></span> <span class="keyword type"><span class="pre">T</span></span> <span class="operator word"><span class="pre">=</span></span> <span class="keyword type"><span class="pre">T</span></span> <span class="punctuation"><span class="pre">{</span></span> <span class="name"><span class="pre">member</span></span> <span class="operator word"><span class="pre">::</span></span> <span class="keyword type"><span class="pre">M</span></span> <span class="punctuation"><span class="pre">}</span></span></tt> のようにして宣言する)．
オブジェクト指向言語ではクラスというほうがわかりやすいだろう．レコード型というのは，
いくつかのメンバ(フィールド，プロパティ)を持つような型のこと．たとえば，
{x::Int,y::String} のように書いたとすれば， これは Int 型の x と
String 型の y を持つような型のことになる．</p>
<p>そこで，次のような関数を考えてみる．</p>
<p>r#x というのは， r のメンバ x にアクセスするという意味だ．</p>
<p>そこでこの関数に，</p>
<p>のような引数を適用したとしよう．しかし次のような項は型付けできない．</p>
<p>ラムダが引数の型として <tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> を要求しているのに対して，
実際の引数は <tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> という型を持つ．もし型エラーになる
理由がわからないのであれば， <tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> を Int， <tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> を
String などと置き換えて考えてみてほしい． Int を要求しているのに String が
渡されている，というのが型エラーとなる理由だ．これは直観に反している．
<tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> と <tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> の関係は， Int と
String などとは違い， <tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> は， 実際に x というメンバを持つから，
<tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> である条件を満たしているじゃないか．</p>
<p>この直観に従った規則が部分型で，部分型を利用すると，上記のような項に型を付けることができる．</p>
<p>部分型は，型システム入門の 15章で触れられている．興味があれば読んでみてほしい．</p>
<div class="section" id="id2">
<h2>部分型関係<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>形式的な議論はしない．厳密な定義は型システム入門を読んでみてほしい．
要約すると，たとえば，</p>
<p>は</p>
<p>の部分型である，というような関係をいう．
メンバの数が多いほうが部分型なのだ．部分型は．オブジェクト指向言語に慣れ親しんだ
人には，サブクラスと言った方がわかりやすいかもしれない．スーパークラスのほうが
メンバが少なく，サブクラスのほうがメンバが多い．(もちろん，継承は部分型ではない．
くれぐれも注意してほしい．)</p>
<p>S が T の部分型であるとき， S の要素はすべて T でもある．
簡単に言うと， S は T にアップキャストできるというわけだ．( T は S にダウンキャスト
できない ． )</p>
<p>この関係を</p>
<p>のように書く．たとえば</p>
<p>である．</p>
<p>関数の引数や関数の戻り値に部分型を使うとき，どのように操作したら安全かを
指定する必要がある．これは次のように書くのがいちばんわかりやすい．</p>
<p>まず左の前提(横線より上の左側)について．これは関数の引数に関する制約を言ってる．
もし T_1 が S_1 の部分型なら， S_1→S_2 は T_1→T_2 の部分型である．
S_1→S_2 は， T_1→T_2 にアップキャストできると言ってる．</p>
<p>例示は理解の試金石だ．具体例で考えよう．
次のように置き換えてみると，わかりやすいと思う．</p>
<p>この規則が言ってるのは， <tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> を受け取る関数は，
<tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> も受け取ることができる，ということだ．</p>
<p>「もし T_1 が S_1 の部分型なら， S_1→S_2 は T_1→T_2 の部分型である」
という文章の「なら」の前後で T_1 と S_1 の向きが逆になってる．
このような規則を反変という．</p>
<p>次の右側の前提について．これは関数の戻り値に関する制約を言ってる．
もし S_2 が T_2 の部分型なら， S_1→S_2 は T_1→T_2 の部分型である．</p>
<p>次のように置き換えてみると，わかりやすいと思う．</p>
<p>この規則が言ってるのは， <tt class="docutils literal"><span class="pre">{x:Nat,y:Nat}</span></tt> を返す関数は，
<tt class="docutils literal"><span class="pre">{x:Nat}</span></tt> を返す関数とみなすこともできる (キャストできる)，
ということだ．</p>
<p>「もし S_2 が T_2 の部分型なら， S_1→S_2 は T_1→T_2 の部分型である」
という文章の「なら」の前後で T_2 と S_2 の向きは同じだ．
このような規則を共変という．</p>
</div>
</div>


    </div>

</body>
</html>