C言語のビットフィールド
================================================================================

.. raw:: html

    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

C言語にはビットフィールドというものがあるらしい．通常， Cのコードは， char, int, long
などの単位で変数の領域を管理する． char は 8ビット， int は 32ビット， long は 64ビットなど．
だから，この単位ででプログラミングする限り， 1ビットの領域を扱ったりはできない．しかし，
たとえば， 0 か 1 かという情報しか保持しないフラグを扱うのに， char で 8ビット使用するのは無駄
だ．単に，一時的な変数であればよいが，たとえば，言語処理系で， Mark&Sweep GC などを実装する
際に，すべてのオブジェクトに 8ビットのフラグを用意してしまうのは，あまりに無駄だ．C言語の
ビットフィールドがどういうものかといえば，そういうときに，例外的に， 1ビットや2ビットなど，
ビットを指定して領域の大きさを決定できる機能だ．以下はそれを使用する例だ．

.. literalinclude:: a.c
   :language: c
   :linenos:

このコードをコンパイルしして実行すると，次のように表示される．

.. literalinclude:: a-out.txt


構造体 X の大きさはたったの 1バイトだけど， 8 つのフィールドをもっている．
それぞれのフィールドは，ビットフィールドで 1ビットであると指定されている．
1ビットのフィールドが 8つあるから，全体として 1バイト(= 8ビット)なのだ．

1ビットのフィールド f3 に 2 を格納して，取り出すと， 0 になっていることがわかる．
1ビットのフィールド f4 に 3 を格納して，取り出すと， 1 になっていることがわかる．

数値の2進数表現を思い出してみよう．

* 0 の 2進数表現

  ====  ====  ====  ====
   0     0     0     0
  ====  ====  ====  ====

* 1 の 2進数表現

  ====  ====  ====  ====
   0     0     0     1
  ====  ====  ====  ====

* 2 の 2進数表現

  ====  ====  ====  ====
   0     0     1     0
  ====  ====  ====  ====

* 3 の 2進数表現

  ====  ====  ====  ====
   0     0     1     1
  ====  ====  ====  ====

フィールドに1ビットしか格納できない，というのは，この2進数表現のうちの，
右端の1列しか格納できないということだ．すると， 2 は右端の 0 しか
格納できず， 3 は右端の 1 しか格納できない．したがって， 1ビットの
フィールドに 2 をいれると， 0 になってしまい， 3 をいれると， 1 になって
しまうのだ．

しかし，ビットフィールドは，ガチ勢のツイッタラによれば，あまり
よい機能ではないらしい．いわく，

.. raw:: html

    <blockquote class="twitter-tweet" lang="ja"><p>ビットフィールドとか地雷臭しかしない</p>&mdash; 勇士Ｑ (@ucq) <a href="https://twitter.com/ucq/statuses/408858176855896065">2013, 12月 6</a></blockquote>

他にも，移植性や，規格などに言及したたくさんのツイットが見られたのだけど，
探すことが困難になってしまったのと，この記事はビットフィールドの是非を問いたい
わけではないので割愛する．

さて，ビットフィールドはあまりよい機能ではないらしいけど，じつは，
ビット演算などを使用して，マクロや関数で同じような機能を実現することが
できるらしい．それを実装してみた．目標は， struct X {..} と同じようなことを
typedef char X で 実現することにある．

.. literalinclude:: b.c
   :language: c
   :linenos:

このコードをコンパイルしして実行すると，次のように表示される．

.. literalinclude:: b-out.txt

このコードがなにをしているのかをいちおう解説してみよう．
まず， BITGET(x,n) マクロとはなにするものぞ．
それは， x の n ビットめの値を得るマクロだ．
x が， char である 0 だとすると， x の 2 進数表現は次のようになる．

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     0     0 
====  ====  ====  ====  ====  ====  ====  ====

8 ビットあるのだから， 8つのフラグを情報として収められそうだ．
たとえば， x = 0xa だとしてみると， x の 2 進数表現は次のようになる．

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     1     0     1     0 
====  ====  ====  ====  ====  ====  ====  ====

このとき， BITGET(x, 0) で 0 を返してほしいし
BITGET(x, 1) で 1 を返してほしいし，
BITGET(x, 2) で 0 を返してほしいし，
BITGET(x, 3) で 1 を返してほしいわけだ．

n = 0 の場合は，単に， 1 で マスクしてやればよさそうだ．

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     1     0     1     0 
====  ====  ====  ====  ====  ====  ====  ====

&

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     0     1 
====  ====  ====  ====  ====  ====  ====  ====

= 

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     0     0 
====  ====  ====  ====  ====  ====  ====  ====

n = 1 の場合は， 「1 を1ビット左にずらしたもの」 で
マスクしたものを， 1 ビット右にずらせばよさそうだ．

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     1     0     1     0 
====  ====  ====  ====  ====  ====  ====  ====

&

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     1     0
====  ====  ====  ====  ====  ====  ====  ====

= 

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     1     0 
====  ====  ====  ====  ====  ====  ====  ====

を 1ビット右にずらす

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     0     0     0     1 
====  ====  ====  ====  ====  ====  ====  ====

帰納法で， n = k の場合は， 「1 をkビット左にずらしたもの」 で
マスクしたものを， k ビット右にずらせばよさそうだ．


BITSET も同じような感じで実装する． BITSET(x,v,n) は，
v を， x の n ビットめに格納する． v は 0 か 1 のみだ．
もし， v が　2 や 3ならぱ，いちばん右端の1ビット以外は
切り捨ててしまう．

たとえば， x = 0xa だとしてみると， x の 2 進数表現は次のようになる．

====  ====  ====  ====  ====  ====  ====  ====
  0     0     0     0     1     0     1     0 
====  ====  ====  ====  ====  ====  ====  ====

このとき， BITSET(x, 0, 0) で x = 0b1010 としてほしいし，
BITSET(x, 0, 1) で x = 0b1000 としてほしいし，
BITSET(x, 0, 2) で x = 0b1010 としてほしいし，
BITSET(x, 0, 3) で x = 0b0010 としてほしいわけだ．

n = 0 の場合は，まず， v は 1ビットしか格納できないという
のだから， 1 でマスクする．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．

n = 1 の場合は，まず， v を 1 でマスクし，それを 左へ
1 ビットずらす．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．

帰納法で， n = k の場合は，まず， v を 1 でマスクし，それを 左へ
k ビットずらす．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．

そして， BITGET と BITSET を使用すると，
なんと char の変数をあたかも struct X のように使用できる．
つまり， char に 8つのフラグを情報として持たせることができた．





