<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
      <title>C言語のビットフィールド</title>
    

    <link rel="stylesheet" type="text/css" href="../../../_static/main.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
</head>
<body>

    <div class="body">
        
  <div class="section" id="c">
<h1>C言語のビットフィールド<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h1>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>C言語にはビットフィールドというものがあるらしい．通常， Cのコードは， char, int, long
などの単位で変数の領域を管理する． char は 8ビット， int は 32ビット， long は 64ビットなど．
だから，この単位ででプログラミングする限り， 1ビットの領域を扱ったりはできない．しかし，
たとえば， 0 か 1 かという情報しか保持しないフラグを扱うのに， char で 8ビット使用するのは無駄
だ．単に，一時的な変数であればよいが，たとえば，言語処理系で， Mark&amp;Sweep GC などを実装する
際に，すべてのオブジェクトに 8ビットのフラグを用意してしまうのは，あまりに無駄だ．C言語の
ビットフィールドがどういうものかといえば，そういうときに，例外的に， 1ビットや2ビットなど，
ビットを指定して領域の大きさを決定できる機能だ．以下はそれを使用する例だ．</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f3</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f5</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f6</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f7</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f8</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;sizeof(struct X) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">X</span><span class="p">)));</span>

    <span class="k">struct</span> <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f4</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;x.f1 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">f1</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;x.f2 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">f2</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;x.f3 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">f3</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;x.f4 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">f4</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>このコードをコンパイルしして実行すると，次のように表示される．</p>
<div class="highlight-python"><pre>sizeof(struct X) = 1
x.f1 = 0
x.f2 = 1
x.f3 = 0
x.f4 = 1
</pre>
</div>
<p>構造体 X の大きさはたったの 1バイトだけど， 8 つのフィールドをもっている．
それぞれのフィールドは，ビットフィールドで 1ビットであると指定されている．
1ビットのフィールドが 8つあるから，全体として 1バイト(= 8ビット)なのだ．</p>
<p>1ビットのフィールド f3 に 2 を格納して，取り出すと， 0 になっていることがわかる．
1ビットのフィールド f4 に 3 を格納して，取り出すと， 1 になっていることがわかる．</p>
<p>数値の2進数表現を思い出してみよう．</p>
<ul>
<li><p class="first">0 の 2進数表現</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">1 の 2進数表現</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">2 の 2進数表現</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">3 の 2進数表現</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>フィールドに1ビットしか格納できない，というのは，この2進数表現のうちの，
右端の1列しか格納できないということだ．すると， 2 は右端の 0 しか
格納できず， 3 は右端の 1 しか格納できない．したがって， 1ビットの
フィールドに 2 をいれると， 0 になってしまい， 3 をいれると， 1 になって
しまうのだ．</p>
<p>しかし，ビットフィールドは，ガチ勢のツイッタラによれば，あまり
よい機能ではないらしい．いわく，</p>
<blockquote class="twitter-tweet" lang="ja"><p>ビットフィールドとか地雷臭しかしない</p>&mdash; 勇士Ｑ (@ucq) <a href="https://twitter.com/ucq/statuses/408858176855896065">2013, 12月 6</a></blockquote><p>他にも，移植性や，規格などに言及したたくさんのツイットが見られたのだけど，
探すことが困難になってしまったのと，この記事はビットフィールドの是非を問いたい
わけではないので割愛する．</p>
<p>さて，ビットフィールドはあまりよい機能ではないらしいけど，じつは，
ビット演算などを使用して，マクロや関数で同じような機能を実現することが
できるらしい．それを実装してみた．目標は， struct X {..} と同じようなことを
typedef char X で 実現することにある．</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">char</span> <span class="n">X</span><span class="p">;</span>

<span class="cp">#define BITGET(x, n)    ((x &amp; (1 &lt;&lt; n)) &gt;&gt; n)</span>
<span class="cp">#define BITSET(x, v, n) (x |= ((v &amp; 1) &lt;&lt; n))</span>

<span class="cp">#define F1_GET(x)       BITGET(x, 0)</span>
<span class="cp">#define F1_SET(x, v)    BITSET(x, v, 0)</span>

<span class="cp">#define F2_GET(x)       BITGET(x, 1)</span>
<span class="cp">#define F2_SET(x, v)    BITSET(x, v, 1)</span>

<span class="cp">#define F3_GET(x)       BITGET(x, 2)</span>
<span class="cp">#define F3_SET(x, v)    BITSET(x, v, 2)</span>

<span class="cp">#define F4_GET(x)       BITGET(x, 3)</span>
<span class="cp">#define F4_SET(x, v)    BITSET(x, v, 3)</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;sizeof(X) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)));</span>

    <span class="n">X</span> <span class="n">x</span><span class="p">;</span>            <span class="cm">/* struct X x;  */</span>
    <span class="n">F1_SET</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   <span class="cm">/* x.f1 = 0;    */</span>
    <span class="n">F2_SET</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   <span class="cm">/* x.f2 = 1;    */</span>
    <span class="n">F3_SET</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>   <span class="cm">/* x.f3 = 2;    */</span>
    <span class="n">F4_SET</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>   <span class="cm">/* x.f4 = 3;    */</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;F1_GET(x) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">F1_GET</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;F2_GET(x) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">F2_GET</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;F3_GET(x) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">F3_GET</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;F4_GET(x) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">F4_GET</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>このコードをコンパイルしして実行すると，次のように表示される．</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mh">0xa</span>
<span class="n">F1_GET</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">F2_GET</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">F3_GET</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">F4_GET</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>このコードがなにをしているのかをいちおう解説してみよう．
まず， BITGET(x,n) マクロとはなにするものぞ．
それは， x の n ビットめの値を得るマクロだ．
x が， char である 0 だとすると， x の 2 進数表現は次のようになる．</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>8 ビットあるのだから， 8つのフラグを情報として収められそうだ．
たとえば， x = 0xa だとしてみると， x の 2 進数表現は次のようになる．</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>このとき， BITGET(x, 0) で 0 を返してほしいし
BITGET(x, 1) で 1 を返してほしいし，
BITGET(x, 2) で 0 を返してほしいし，
BITGET(x, 3) で 1 を返してほしいわけだ．</p>
<p>n = 0 の場合は，単に， 1 で マスクしてやればよさそうだ．</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>&amp;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>=</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>n = 1 の場合は， 「1 を1ビット左にずらしたもの」 で
マスクしたものを， 1 ビット右にずらせばよさそうだ．</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>&amp;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>=</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>を 1ビット右にずらす</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>帰納法で， n = k の場合は， 「1 をkビット左にずらしたもの」 で
マスクしたものを， k ビット右にずらせばよさそうだ．</p>
<p>BITSET も同じような感じで実装する． BITSET(x,v,n) は，
v を， x の n ビットめに格納する． v は 0 か 1 のみだ．
もし， v が　2 や 3ならぱ，いちばん右端の1ビット以外は
切り捨ててしまう．</p>
<p>たとえば， x = 0xa だとしてみると， x の 2 進数表現は次のようになる．</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>このとき， BITSET(x, 0, 0) で x = 0b1010 としてほしいし，
BITSET(x, 0, 1) で x = 0b1000 としてほしいし，
BITSET(x, 0, 2) で x = 0b1010 としてほしいし，
BITSET(x, 0, 3) で x = 0b0010 としてほしいわけだ．</p>
<p>n = 0 の場合は，まず， v は 1ビットしか格納できないという
のだから， 1 でマスクする．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．</p>
<p>n = 1 の場合は，まず， v を 1 でマスクし，それを 左へ
1 ビットずらす．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．</p>
<p>帰納法で， n = k の場合は，まず， v を 1 でマスクし，それを 左へ
k ビットずらす．それと x で ビット毎の OR
をとったものを x に格納すればよいわけだ．</p>
<p>そして， BITGET と BITSET を使用すると，
なんと char の変数をあたかも struct X のように使用できる．
つまり， char に 8つのフラグを情報として持たせることができた．</p>
</div>


    </div>

</body>
</html>