Clojure で構文木を単純に型付けする
================================================================================

.. include:: /roles.rst

世の中のプログラミング言語には，静的型付き言語と呼ばれるものがある．
静的型付「け」言語などと言うと，Twitterで，
`@seitekibot <https://twitter.com/seitekibot>`_ に補足されるので注意が必要だ．
静的型付き言語の目指すところは，型システム入門によれば，プログラムを実際には実行すること
なく，プログラムの妥当性を検証することにあるらしい．たとえば， 整数に1を足す
``inc`` 関数と，論理値である ``false`` があったとして， ``(inc false)`` は
明らかに間違ったプログラムだ．たとえ動的に型検査するとしても，このプログラムの
評価が行き詰まってしまうのは必然に思える．であらば，このプログラムを実行できても
なんの意味もない．そういったプログラムを，実行や，コンパイルするより前の段階で，
できるだけ発見してしまおう，というのが静的型システムを実装するモチベーションらしい．
今回は，型システム入門の第8章を参考に，簡単な型システムを実装してみる．

静的型システム？
--------------------------------------------------------------------------------

静的型システムは， AST を走査して，項に，型と呼ばれるものを割り当て，
矛盾した項がないか探すシステム．たとえば， ``false`` は 型 Bool を持つ．
``0`` は Int の型を持つ． ``(inc x)`` は， もし ``x`` が 型 Int
を持つなら，型システムの検査をパスし，型 Int を持つが，
もし， ``x`` が 型 Int を持たないなら，型システムが
それを知らせ，言語はそのプログラムを拒絶する．
そうすることで，まちがったプログラムの実行をしないようにする．

実装
--------------------------------------------------------------------------------

言語として Clojue を採用する．理由は， AST の走査をするなら Lisp がよいと
思ったからだ． Lisp なら，面倒なパーサを書くことなく，リストを構文木として使用できる．
そして，それは読みやすい．

今回実装する型は，それほど複雑なものにはしない．型付けできるのは，

* :clj:`true`
* :clj:`false`
* :clj:`0`
* :clj:`(succ x)`
* :clj:`(pred x)`
* :clj:`(iszero x)`
* :clj:`(if x y z)`

だけ，ということにする． Clojure のすべての式を型付けするなど
ということは目指さない．それは難しいし，目的でもないからだ．

まず，どのように実装するか考える． :hs:`typeof :: AST -> Either Failure Type`
のような関数をつくることにしよう． AST は，構文木の型で， Clojure では
単にリストということになる． Failure は， :hs:`data Failure = Failure [Info]` かつ
:hs:`data Info = Info { expected :: Type, actual :: Type, astAt :: [Int] }` のような
型で，型エラーの位置を知らせる． expected は期待された型で， actual は実際の型だ．
astAt は，たとえば， :clj:`(if (iszero false) 0 0)` のように
したとすれば，それを x ということにして，x の :clj:`(nth (nth x 1) 1)` の位置で型
エラーが起こっている，という， AST のどの位置かを示すポジションのリストだ．
この例では， :hs:`astAt = [1,1]` ということになる．
:clj:`(reduce nth ast ast-at)` のように
して，エラーが起こっている AST まで辿れるということにする．これは，人間が
どこでエラーが起こっているか知るメッセージをつくるためにある．
Type は， Boolean, Long のどちらかということにする．
ラムダ式の型付けはすこし複雑だから，今回はしないということにする．

実際の Clojure でのデータの定義は，次のようになる．

.. literalinclude:: tyarith.clj
   :language: clojure
   :lines: 1-3

それから， typeof 関数を定義する． typeof は，ほとんど単純な場合分けしかしない．

print-typeof 関数を定義して，正しい型ならそれを，まちがった型なら
その情報を表示するようにする．そのコードを使用して，次のように
テストコードを書く．

.. literalinclude:: tyarith.clj
   :language: clojure
   :lines: 93-106

このコードを実行すると，次のように表示される．

.. literalinclude:: output.txt

完全なコードは次のようになった．

.. literalinclude:: tyarith.clj
   :language: clojure
   :linenos:
