Clojure でλ計算の構文木を単純に型付けする
================================================================================

.. include:: /roles.rst

:doc:`/blog/entry/2013-10-27/index` の続きを書こうと思う．前回は，ラムダを型付け
しなかった．今度は，ラムダの型付けも含む．

ラムダの型付け？
--------------------------------------------------------------------------------

ラムダの型の割り当ては，単純な型付けよりちょっと複雑になる．
まず，型環境という型の情報に関する環境が必要になる．たとえば，

.. code::

   λx:T.x

のようにすると，まず，型環境に ``x`` が ``T`` であると割り当てる．
そのあと，この環境に基づいて， ``x`` を型付けすると， ``T`` であるということに
なる．このとき，たとえば，

.. code::

   λx:T.y

のようにして，割り当てられていない名前を探そうとすると，これは，名前が見つからない
というようにエラーになる．

ラムダ自体は， ``T→T'`` のような型を持つということにする．たとえば，

.. code::

   λx:T.x

は ``T→T`` という型を持つ．

次に，適用に関する規則も必要になってくる．適用に関する規則は，たとえば，

.. code::

   λf:T→T'.λx:T.fx

のようにすると， ``f:T→T'`` と ``x:T`` から， ``fx:T'`` となる．
このラムダ自体は， ``(λf:T→T'.λx:T.fx):(T→T')→T→T`` のように
して型付けされる．

実装
--------------------------------------------------------------------------------

ほとんどは， :doc:`/blog/entry/2013-10-27/index` と同じように実装する．
必要な規則として，λ-導入と，λ-除去を追加する．今回は，次のような項を型つけする
ということにする．

* :clj:`42` のような数値
* :clj:`(lambda x T y)` - λ-導入
* :clj:`(f x)` - λ-除去

型として :clj:`Arr` を追加する． Arr は， Arrow の略で， 関数の型
という意味だ． Clojure での定義は，次のようになる．

.. literalinclude:: simply.clj
   :language: clojure
   :lines: 6

:clj:`(lambda x T y)` は，まず，型環境の ``x`` に ``T`` を割り当て，
その環境のもとで ``y`` を型付けする．たとえば :clj:`(lambda x Long x)` は
:clj:`#Arr{:src java.lang.Long, :tgt java.lang.Long}` のような
型を持つということだ．
:clj:`(f x)` は，もし f が型 :clj:`Arr{:src T, :tgt R}` を持って
いて， x が型 ``T`` を持つなら， 型 ``R`` を持つ．

さて，今回実装したものを，実際に動かしてみる．

.. literalinclude:: simply.clj
   :language: clojure
   :lines: 81-93

このコードを実行すると，次のように表示されるはずである．

.. literalinclude:: output.txt

完全なコードは次のようになった．

.. literalinclude:: simply.clj
   :language: clojure
   :linenos:
