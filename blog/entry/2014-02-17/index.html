<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
      <title>λρ-計算とcall/ccの型付け</title>
    

    <link rel="stylesheet" type="text/css" href="../../../_static/main.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
</head>
<body>

    <div class="body">
        
  <div class="section" id="call-cc">
<h1>λρ-計算とcall/ccの型付け<a class="headerlink" href="#call-cc" title="Permalink to this headline">¶</a></h1>
<p>読者はもちろん λ-計算くらい完全に理解されていると思う．
λ-計算は万人の教養であるが， λρ-計算は聞き慣れないであろう．
ぼくも昨日知ったばかりである．ちょっと勉強したところ，たいへん面白そうであるので，
ブログにしておこうと思う．</p>
<p><a class="reference external" href="http://komoriyuichi.web.fc2.com/symposium/lambda-rho5.pdf">λρ-calculus</a>
を読んだ．定義や，証明などはこの paper を参照してもらうことにして，
ここでは，例をつらつら書いてみる．</p>
<p>型なしλρ-項および型付きλρ-項の定義は， Definition 1.1 と
Definition 2.1 をそれぞれ参照してほしい．</p>
<p>次の記号は，型なしλρ-項の例である．</p>
<p>λxa.x(λy.ay)</p>
<p>また，型付きλρ-項としては次のように書く．</p>
<p>λxa.x(λy.(ay)^β):((α→β)→α)→α</p>
<p>ここで， x, y はλ-変数であり， a は ρ-変数 だ．
x がλ-変数で M がλρ-項ならぱ， (λx.M) という形のλρ-項を
λ-抽象といい， a がρ-変数で M がλρ-項ならぱ， (λa.M) という形のλρ-項を
ρ-抽象という，
ちなみに，この項に付けられた型は Peirce の法則という．</p>
<p>a が ρ-変数で M が λρ-項ならば (aM) という形のλρ-項を absurd という <a class="footnote-reference" href="#id5" id="id1">[1]</a> ．
λxa.x(λy.ay) における (ay) の部分のことだ．</p>
<p>(ay)^β における ^β は型注釈で， ay が β という型を持つことを明示している．
absurd は不思議な型を持つ． a がρ-変数で，M がλρ-項で， a : Τ であり， M : Τ ならば， (aM)^σ : σ
である．この規則からすぐに， (aM) が任意の型を持つことがわかる．</p>
<p>部分項の型は，それぞれ，</p>
<ul class="simple">
<li>x : (α→β)→α</li>
<li>y : α</li>
<li>a : α</li>
<li>(ay)^β : β</li>
<li>(λy.(ay)^β) : α→β</li>
</ul>
<p>こんな感じになってる．
x の型が謎だ．一体全体，こんな型を持つ関数が存在するのか？
Haskell には fix (Yコンビネータ) くらいしかないと思う…</p>
<p>簡約の定義によれば， absurd はおかしな簡約のされ方をする．
a がρ-変数ならば， ((a M)^σ→Τ)N は (a M)^Τ に簡約される．
absurd は任意の型を持つので，たとえば α→β→γ→…→Τ と延々続く
型を持つこともできる．すると，</p>
<ul class="simple">
<li>((a M)^α→β→γ→δ→Τ N M P Q)</li>
<li>→ ((a M)^β→γ→δ→Τ M P Q)</li>
<li>→ ((a M)^γ→δ→Τ P Q)</li>
<li>→ ((a M)^δ→Τ Q)</li>
<li>→ (a M)^Τ</li>
</ul>
<p>こんな感じに簡約されそうだ．</p>
<p>だから， ρ-変数 を引数に適用すると，
ひとつめの引数がずっと保存されて，
残りの引数はすべて捨てられてしまうわけだ．</p>
<p>それから，ρ-抽象を引数に適用すると，面白い動きをする．</p>
<p>a が ρ-変数ならぱ， (λa.M)N は λb.([λx.b(xN)/a]M)N に簡約される．
なにやら複雑であるが，これはρ-変数に対する代入だ．
通常のλ-抽象の代入と同じように，展開してみると，
「ρ-変数に与えられた引数を持ち上げて，それにNが与えられる」みたいな感じの
動きをする．たとえば，</p>
<p>(λa.aMN)R</p>
<p>という形を考えてみる．これは，</p>
<ul class="simple">
<li>(λa.aMN)R</li>
<li>→ λb.([λx.b(xN)/a](aMN))R</li>
<li>≡ λb.((λx.b(xR))MN)R</li>
<li>→ λb.(([M/x]b(xR))N)R</li>
<li>≡ λb.b(MR)NR</li>
<li>→ λb.b(MR)R</li>
<li>→ λb.b(MR)</li>
</ul>
<p>こんな感じに簡約される．</p>
<p>言葉で説明するのは，なかなか難しいのだけど，
とにかく， (λa.aMN)R のような形だと，最初に a に与えられた値が飛ぶように
λa. の場所まで戻ってしまう．それ以外の値は，すべて無視される．</p>
<p>なんとなく，似たものをわれわれは知っている．
そう， Scheme の call/cc である．</p>
<ul class="simple">
<li>ρ-変数は第一級継続に，</li>
<li>ρ-抽象 λa.M は (call/cc (lambda (a) M)) に，</li>
</ul>
<p>それぞれ似ている．じっさいに，さっきの項を，継続として書いてみると，</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">((</span><span class="nb">call/cc </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">((</span><span class="nf">a</span> <span class="nv">M</span><span class="p">)</span> <span class="nv">N</span><span class="p">)))</span> <span class="nv">R</span><span class="p">)</span>
</pre></div>
</div>
<p>こんな感じになるだろう．</p>
<p>この Scheme のコードは，実際に， N を無視して，
M を call/cc の外側まで飛ばす．そして， (M R) が実行される．</p>
<p>さて，では， ρ-抽象が call/cc だというなら， Peirce の法則の証明である
λxa.x(λy.(ay)^β):((α→β)→α)→α も Scheme で書けそうである．愚直に翻訳すると，</p>
<div class="highlight-scheme"><div class="highlight"><pre><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">call/cc </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">y</span><span class="p">))))))</span>
</pre></div>
</div>
<p>となる．</p>
<p>このコードになにか意味があるとは思えないけども，
λρ-計算で型がつけられるのだから， Scheme でも型がつけられそうである．
部分項の型を列挙すると，</p>
<ul class="simple">
<li>x : (α→β)→α</li>
<li>y : α</li>
<li>a : α</li>
<li>(a y) : β</li>
<li>(lambda (y) (a y)) : α→β</li>
<li>(x (lambda (y) (a y))) : β</li>
<li>(lambda (a) (x (lambda (y) (a y)))) : α→β</li>
<li>(call/cc (lambda (a) (x (lambda (y) (a y))))) : β</li>
</ul>
<p>こんな感じになる． call/cc も関数だから，たぶん，引数である
(lambda (a) (x (lambda (y) (a y)))) : α→β の型を仮定した型になるだろう．
つまり，</p>
<ul class="simple">
<li>call/cc : (α→β)→β</li>
</ul>
<p>になるんだと思う…(自信なさげ)</p>
<p>と，ここまで書いたわけであるが，
<a class="reference external" href="http://pllab.is.ocha.ac.jp/~asai/jpapers/ppl/ueda10.pdf">型付き対称λ計算と古典論理</a>
という文献や， <a class="reference external" href="http://www.cl.cam.ac.uk/~tgg22/publications/popl90.pdf">A Formulae-as-Types Notion of Control</a>
という文献を見つけた．たぶんこれを読んだほうがいいのだろう…</p>
<div class="section" id="id3">
<h2>参考文献<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://komoriyuichi.web.fc2.com/symposium/lambda-rho5.pdf">λρ-calculus</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>absurd の訳語をぼくは知らないのです．へたな用語の発明は避けたいので，そのまま書くこととします．詳しい人教えてください．</td></tr>
</tbody>
</table>
</div>
</div>


    </div>

</body>
</html>