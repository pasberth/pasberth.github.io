理想のプログラミング言語は CSS かもしれない
================================================================================

アセンブリ言語では，言語にもよるけども，変数というものがない．正確にいえば，ローカル変数が
ないと言った方がいいのかもしれない．かわりに，レジスタという，ある意味でいえば，グローバル
変数のようなものを共用して，関数の引数を渡したり，戻したりするのである．次のコードは，
`OS X のアセンブリ言語 <https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/020-Assembly_Language_Syntax/asm_syntax.html#//apple_ref/doc/uid/TP30000821-TPXREF101>`_
で， gcc の呼び出し規約を期待した，ただインクリメントするだけの関数だが，それが現れて
いる． %edi というレジスタには，第一引数として，整数が入っているはずだ．
%eax は，戻り値を格納するレジスタだ．

.. literalinclude:: inc.s
   :language: asm

自然言語で読めば，

1. %edi の内容を， %eax にコピーしろ
2. 1 を， %eax に加えろ
3. 戻れ

となる．

アセンブリ言語で，もうすこし発展した問題を扱ってみよう．次のコードは，同じ OS X のアセンブリ言語で，
1 から 15 までの和を求めるコードだ．

.. literalinclude:: sum.s
   :language: asm

main 関数を，自然言語で読めば，

1. %rbp を 8ビット下方にずらせ
2. 0 を， -4(%rbp) にコピーしろ
3. 1 を， -8(%rbp) にコピーしろ
4. *ラベル L2* にジャンプしろ
5. **ラベル L1**:
  1. %eax の内容を， -8(%rbp) にコピーしろ
  2. -4(%rbp) の内容を， %eax に加えろ
  3. 1 を， -8(%rbp) に加えろ
6. **ラベル L2**:
  1. 15 と -8(%rbp) を比較しろ
  2. もし，比較した結果が低いまたは同じなら， *ラベル L1* にジャンプしろ
  3. -4(%rbp) の内容を， %esi にコピーしろ
  4. LC0(%rip) の内容を， %rdi にコピーしろ
  5. printf 関数を呼びだせ
  6. %rbp を 8ビット上方にずらせ
  7. 0 を， %eax にコピーしろ
  8. 戻れ

となる．自然言語で書いたら，この命令はあまりに機械的過ぎて，
意味がわからないだろう． (バイナリアンを除く)

C言語では，その操作が抽象化されている．レジスタの操作を引数と呼んだり，スタックの操作を
ローカル変数と呼び， 具体的な操作を隠蔽し，抽象的な概念を表現している．
そのおかげで，アセンブリ言語に比べれば，ずいぶんとプログラミングが
しやすいようだ．次のコードは， 1 から 15 までの和を求める
コードだ．

.. literalinclude:: sum.c
   :language: c

自然言語で読めば，

1. int である sum を用意し， 0 で初期化しろ
2. int である i を用意し， 1 で初期化しろ
3. sum の内容に， i を加えろ
4. i の内容に， 1 を加えろ
5. もし， i が，
  1. 15 以下であるならば， 3 に戻れ
  2. 15 を超えているならば， 6 へ行け
6. sum の内容を印字しろ

となる．

C言語はかなり抽象化された言語だと思う．しかし，まだ抽象化が足らない部分がある．
そう， C言語では，繰り返しに i という変数を使用して，条件式で
分岐しなければならない．

Python では，その操作が抽象化されている．繰り返しに，変数と条件式を使用する
必要はない． for i in .. というようにして，簡単に書くことができる．

.. literalinclude:: sum.py
    :language: python

自然言語で読めば，

1. sum を用意し， 0 で初期化しろ
2. 1 から 16 までの範囲の数値(ただし16は含まない)を用意し，それぞれの数値 i に対して，次の操作を繰り返せ:
  1. sum の内容に， i を加えろ
3. sum の内容を印字しろ

ずいぶんと列挙すべき内容が減った． Python はかなりレイヤーが高い言語だ．
しかし，まだ抽象化が足らない部分がある．そう， Python でもまだ，一時変数を使用し，
この変数に次々と値を加算することで合計を求めている．いわゆる，手続き型言語的なコードだ．
この操作は，ある意味，アセンブリ言語から進歩してない部分といえる．一時変数と，
レジスタ，なにが違うっていうのだ？

Haskell では，さらに抽象化が進んでいる．もはや一時変数を書く必要はない．
foldl を使用して，一時変数が関数の引数という形で抽象化されている．

.. literalinclude:: sum.hs
   :language: hs

自然言語で読めば，

1. 0 を初期値として， 1 から 15 までの範囲の数値を，順々に足せ． (たとえば， (((0+1)+2)..+k) というふうに． )
2. それを印字しろ

となる．

さて，ここまで，数々の抽象化を，段階を経てみてきた．
ここまででなにか感じたことはないだろうか．
ぼくは，このようにいろいろな言語を見ていると，抽象化がなされるにつれ，
より命令を書かないようになっていると思う．命令というのは，つまり，
機械に対するインストラクションのことだ．人間が機械に対して命令する代わりに，
人間がしたいことだけを書けるようになっているというのだ．
今回の例でいえば，人間がしたいことをは，15の和を求め，それを画面に印字することであって，
どのレジスタに引数をいれるか考えたり， i をカウントしてループを抜ける条件を提案したり，
sum というアキュムレータに次々と数値を足せと命令したりすることではないのだ．
そういう余分な部分を剥ぎ取って，代わりに，人間がしたいことのみを書けるようになっている
というのだ．関数型プログラミングは，今回の例でいえば，したいことだけを書くことができた．

しかし，この記事の題にも見られる通り，この記事で言いたいのは，関数型プログラミングが
最高だなんて宗教じみた主張ではないのだ．関数型プログラミングでも，けっきょく
たくさんの命令を書かなくちゃいけないのは，関数型言語でプログラミングをしていれば
わかることだ．ぼくは，プログラミングをせずに済むことこそが，求められている
最高のプログラミング言語なんじゃないかと思う．ぼくは，さっき，機械に対して命令するという言葉
を使ったけど，言うなれば，プログラミングとは機械に対して命令するということだ．
だから，命令を書かずに済むというのは，プログラミングをせずに済むと言い換えても
同じことだ．つまり，

* したいことが簡単にできて，
* 命令を書かずに済む(プログラミングをする必要がない)言語

がもっとも素晴らしいプログラミング言語のあるべき姿なのだ．

そういう視点に立ったとき，じつは，それに近い言語が今まさに，この現代にあることに気づく．
それは， CSS だ． CSS は，人間がしたいことをかなり柔軟に書くことができる．
人間がしたいことというのは，ウェブデザインだ．それなのにも関わらず，プログラミングを
する必要がない．命令を書かなくてもよい．ゆえに，デザインが崩れるなんてバグはあっても，
無限ループするだとか，メモリリークするだとかいう致命的なバグに合うことはない．

そういうわけで， CSS はなんてすばらしい言語なんだろう，と思った次第である．

