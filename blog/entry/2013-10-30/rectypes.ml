(* μX.(X×Int)→X *)
let f : 'a * int -> 'a as 'a = fst

(* 'a * int -> 'a の 'a が
 * 'a * int -> 'a に展開されたような型を持つ
 *)
let f = f (f, 42)
let f = f ((f (f, 42)), 42)

(* μX.(Int×X) *)
(* a は int と a のペア *)
let rec ones : int * 'a as 'a = (42, ones)

(* 注意: OCaml ではデータコンストラクタの引数は
 * 遅延評価されたように振る舞うので
 * 無限ループにはならない
 *)
let () = print_int (fst ones) ; print_newline ()
let () = print_int (fst (snd ones)) ; print_newline ()

(* Y コンビネータの型付け
 * 単純型付きラムダ計算ではこの関数を型付けできない
 * f:Y→Y かつ x:(μX.X→Y) だということにすると
 *
 *         x:μX.X→Y    x:μX.X→Y             x:μX.X→Y    x:μX.X→Y
 *         --------------------             --------------------
 * f:Y→Y            xx:Y            f:Y→Y            xx:Y
 * ----------------------           ----------------------
 *       f(xx):Y                            f(xx):Y
 * ----------------------           ----------------------
 * λx.f(xx):(μX.X→Y)→Y                λx.f(xx):(μX.X→Y)→Y
 * -------------------------------------------------------
 *                 (λx.f(xx))(λx.f(xx)):Y
 * -------------------------------------------------------
 *           λf.(λx.f(xx))(λx.f(xx)):(Y→Y)→Y
 *
 * というようにして λf.(λx.f(xx))(λx.f(xx)) に (Y→Y)→Y という
 * 型をつけることができる
 *)
let y : ('a -> 'a) -> 'a = fun f ->
  let j : ('b -> 'c as 'b) -> 'c = fun x -> f (x x) in
  j j

(* 注意: 無限ループする *)
(* let () = y (fun x -> x); () *)