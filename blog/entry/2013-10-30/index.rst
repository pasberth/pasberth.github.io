再帰型
================================================================================

.. include:: /roles.rst

型システムの勉強を進めると，ひとつ疑問に思えることがあった．それは， Y コンビネータの
型付けのことだ．型システムは，ASTを走査して，式に静的な型を付ける．ところが，
素直にYコンビネータを型付けしようとすると，おそらくなんらかの型エラーを起こす．
``(λf.(λx.f(xx))(λx.f(xx)))`` という Y コンビネータを考えよう．
この関数の中に， ``xx`` という部分が出現する．
この部分に着目してみる．まず， ``x`` が 型 T→T' を持つと仮定する．
T の具体例はとくに制限していない (Int でも Stringでもよい)．右の x
の型は T→T' だから， 左の x の T の具体例は T→T' ということになる．
したがって，左の x は (T→T')→T' という型を持つ．しかし，右の x は T→T' だ．
左の x と右の x が違う型を持ってしまった．

.. texfigure:: app1.tex
   :alt: App1

型を合わせるため，右の x を (T→T')→T' だということにする．そうすると
今度は左の x は ((T→T')→T')→T' ということになってしまう．

.. texfigure:: app2.tex
   :alt: App2

この議論が無限に繰り返されてしまうわけだ．
簡単に要約すると，たとえば， ``(λx.xx)`` のようなラムダに型をつけることは
できないということだ．実際， GHCi で :hs:`(\x -> x x)` のようにすると
なんかエラーがでるはずだ．

しかし，そういうラムダにも型をつけるのが再帰型というものらしい．再帰型は
型システム入門の21章で触れられている．型システム入門とかではμ型といわれて
いる．

奇しくも OCaml は再帰型をオプションで有効化できるようだ．
``-rectypes`` オプションでこれを有効化できる．
実際に試すには，次のようにすればよい．

.. code::

   $ ocaml -rectypes
   (fun x -> x x)
   # (fun x -> x x);;
   - : ('a -> 'b as 'a) -> 'b = <fun>

さて， :ml:`('a -> 'b as 'a)` という型は，型システム入門の記法を用いれば
``μX.X→Y`` のようになる． as 'a という部分が μX のように書かれる
わけだ．これは， X の部分をその型自体で置換するような型となる．
たとえば， ``μX.X→Y`` は ``(μX.X→Y)→Y`` とか ``((μX.X→Y)→Y)→Y``
になるみたいなイメージだ．

ocaml を使用して， ``μX.(X×Int)→X`` という型をあらわしてみよう．

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 1-8

:ml:`f (f, 42)` は， :ml:`(f, 42)` のような引数をとって f を返す
ということになる． f を返すということは，これにまた :ml:`(f, 42)` のように
渡してもまた f が返るということになる． :ml:`f (f, 42) (f, 42) (f, 42)` のように
してもよい．ちょうど :hs:`id id id id` みたいな感じである．

これを利用すると，再帰するタプルなどの型をあらわすことができる．

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 10-19

さて，本筋としてはこれで Yコンビネータを型付けできるかどうかだ．
実際にやってみよう． まず，こういう推論規則があると考える．

.. texfigure:: rec.tex
   :alt: Rec

f:Y→Y かつ x:(μX.X→Y) だということにすると次の
ようにして λf.(λx.f(xx))(λx.f(xx)) に (Y→Y)→Y という
型をつけることができる

.. texfigure:: y.tex
   :alt: TypedY

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 40-45
