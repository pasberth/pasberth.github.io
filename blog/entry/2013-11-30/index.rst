LLVM でラムダ計算のコンパイラつくった
================================================================================

本格的に言語をつくる前に，練習として，ちょっとしたラムダ計算のコンパイラをつくってみようと
思った．それができなければ，本格的なコンパイラなど夢のまた夢だろう．そういうわけで，
OCaml と LLVM を使用して， ラムダ計算のコンパイラをつくった．

ラムダ計算のコンパイラを実装するということは，オリジナルの言語のコンパイラに，高階関数を
実装することに相当する．ラムダ計算のコンパイラが実装できれば，確かな自信をもって，オレオレ
言語に第一級の関数を仕様として盛り込めるわけだ．

言語として OCaml を使用した．関数型言語はサイコーだ．

まず，目標を決める．今回の目標は，次のような関数をコンパイルして，  C から呼び出せるように
することだ．なぜ C から呼び出せるようにするかというと， printf などを使用して，実際に
動作しているかを目で確認したいから，というのと， printf を言語内から呼び出すのは
ちょっとハードルが高いように思えるからだ．

* ski.txt

  .. literalinclude:: ski.txt
      :language: none
      :linenos:

* C から呼び出すイメージ

  .. code-block:: c

     #include "ski.h"

     int main(int argc, char const *argv[])
     {
       int x = I(42);
        printf("%d\n", x); // 42 と表示される
        return 0;
     }

まず，型を定義する． AST の型は次のようになる．

.. literalinclude:: ast.ml
   :language: ocaml
   :lines: 1-7

たとえば， ``K := \xy.x`` なら， ``Def("K", Lam("x", Lam("y", Ref("x"))))``
のようになる．

次に，この AST のままだと少々抽象的すぎるので， AST のちょっと形を変えたものにして
機械が扱いやすいようにする．

.. literalinclude:: ast.ml
   :language: ocaml
   :lines: 9-18

たとえば， ``K := \xy.x`` なら， ``IxDef("K", IxLam(n, 0, IxLam(m, 1, IxRef(0))))``
のようになる． ``\xy.x`` をよく見ると， ``\01.0`` のようにしても
同じである事がわかる．だから，出現する順に数字に置き換える事で，配列のインデックスを指し示す
ようにできる． ``n`` とか ``m`` とか書いているのは，ラムダ抽象の id だ．
LLVM IR の表現に高階関数なんてものはないので，ラムダはすべて静的な関数に置き換える必要がある．
たとえば， ``\xy.x`` は ``\x.(\y.x)`` と同じで，ラムダの中でラムダが作られているけども，
LLVM IR の表現に直すときは，関数の中で関数をつくることはできないので，関数の外で定義されている
ように置き換える．そこで， まず， ``\x.(..)`` という外側のラムダの id を n，
``...(\y.x)`` という内側のラムダの id を m ということにして，

.. code-block:: llvm

   define void @.anon_func.n() {
     ; .anon_func.m のクロージャをつくる処理
   }

   define void @.anon_func.m() {..}

のようにコンパイルするワケだ．

次に，パーサをつくる．パーサに関しては，一言も言及しなくてもよいだろう．
もしパーサに関して興味があるなら別の記事を読んでみてほしい．

肝心のコンパイラの処理について．実装よりも抽象的な話をする．たとえば， ``\xy.x`` が
どうコンパイルされるか考えてみよう．``\xy.x`` のことを K と呼ぶ事にする．
まず，引数を渡すためのスタックが必要だ．たとえば， ``K(1, 2)`` の呼び出したい場合，
1 と 2 は引数はいったんスタックに格納する． 2 を先にスタックにいれて， 1 をそのあと
スタックにいれる．そのあと関数内でスタックから値をひとつずつ取り出す．そうして関数に
引数を渡すわけだ．スタックはグローバル変数にする．おっと，現在スタックがどの位置を
指し示しているのか記録するスタックポインタも必要だ．

.. literalinclude:: lambda.ml
   :language: ocaml
   :linenos: 33-41

次に，引数を格納する環境が必要だ．渡された引数をあとから参照できるようにしないといけ
ない．スタックから取り出した引数を， x や y のハッシュをとるなりして，あとから見つけられる
ようにする．環境はグローバル変数にすればよいだろう．

.. literalinclude:: lambda.ml
   :language: ocaml
   :linenos: 42

カリー化もできるようにしたい．カリー化をできるようにするには，ひとつめの引数をとった
時点で，その環境を保存した匿名関数を返せばよい．匿名関数 f は， f.env として，
その匿名関数がつくられた時点での環境を保存している．

まとめると， K の動作は，

1. x をスタックから取り出す
2. グローバル環境に x を割り当てる
3. グローバル環境を保存した匿名関数 f' を返す

となる．また，匿名関数 f' の動作は，

1. グローバル環境を環境スタックに積む
2. グローバル環境に f'.env を割り当てる
3. y をスタックから取り出す
4. グローバル環境に y を割り当てる
5. グローバル環境から x を取り出し，それを返す
6. 環境スタックからもともとの環境を取り出し，それをグローバル環境に割り当てる

どうにも文章を書くのは苦手だ．抽象的な話はこれくらいにする．実際のテスト・コードを
読んでもらったほうがいくらかわかりやすいだろう．

.. literalinclude:: test/identity.c
   :language: c
   :linenos:

まず， stack_push() でスタックに引数をひとつ積む．今回は 42 を積んでいる．それから，
スタックに関数を積む． app() を呼ぶと，スタックのいちばん上の関数を取り出して，
その関数を適用する．スタックに積まれている他の値は引数となる．
それから，戻り値はスタックに積んで返されるから， stack_pop() で取り出して
確認する． identity function だから，積んだものがそのまま返されるはずだ．

戻り値がスタックに積まれているから，もし，戻り値が匿名関数なら，そのままもう一度
app() を呼べばそのまま適用できる．たとえば， T は 1つ引数をとって匿名関数を
積む関数になってる．だから [2, 1, T] の順でスタックに積み， app() を呼ぶと，
スタックは [2, <部分適用された関数>] となる．そこでもう一度 app() を呼ぶと，
スタックは [1] となる．

.. literalinclude:: test/bool_true.c
   :language: c
   :linenos:

結果として，次のようなコードがコンパイルできた．

OR, AND, NOT などが完璧に動作している．

* ski.txt

  .. literalinclude:: ski.txt
      :language: none
      :linenos:

Full code listing
--------------------------------------------------------------------------------

* ast.ml

  .. literalinclude:: ast.ml
      :language: ocaml
      :linenos:

* lexer.mll

  .. literalinclude:: lexer.mll
      :language: ocaml
      :linenos:

* parser.mly

  .. literalinclude:: parser.mly
      :language: ocaml
      :linenos:

* lambda.ml

  .. literalinclude:: lambda.ml
      :language: ocaml
      :linenos:

* lambda.ll

  .. literalinclude:: lambda.ll
      :language: llvm
      :linenos:

* ski.txt

  .. literalinclude:: ski.txt
      :language: none
      :linenos:

