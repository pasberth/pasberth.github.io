<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
      <title>Mark&amp;Sweep GC を実装する</title>
    

    <link rel="stylesheet" type="text/css" href="../../../_static/main.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
</head>
<body>

    <div class="body">
        
  <div class="section" id="mark-sweep-gc">
<h1>Mark&amp;Sweep GC を実装する<a class="headerlink" href="#mark-sweep-gc" title="Permalink to this headline">¶</a></h1>
<p>Mark&amp;Sweep は， GC のアルゴリズムの一種で， Ruby などで採用されている．
性能はあまりよろしくないらしい．でも，一度くらい実装してみる．</p>
<p><a class="reference external" href="http://wiki.livedoor.jp/author_nari/d/GC/standard/Mark%26Sweep">GC/standard/Mark&amp;Sweep</a>
などがわかりやすかった．</p>
<p>Mark&amp;Sweep という GC がなにをするか確認してみよう．まず， Mark&amp;Sweep にはルートと呼ばれる
オブジェクトがある．たとえば， Ruby でいえば， ruby -e &#8216;p self&#8217; のようにすると
印字される main という文字列が現すオブジェクトのようなものがそれだ．
それから，ヒープには，プログラム中で使用される全オブジェクトの列が記録されている．
gc を実行すると，ルートオブジェクトが参照するいくつかのオブジェクトは， mark される．
mark するというのは，1 というフラグを立てたりするということだ．さらに，
「ルートオブジェクトが参照するいくつかのオブジェクト」から参照されるオブジェクトも，
mark される．再帰的に参照されるすべてのオブジェクトは mark される．
今や， mark されているか否かを調べれば，どこからか参照されているか，どこからも参照されていないか
わかる．そのあと，ヒープに記録されているすべてのオブジェクトを調べて， mark されていない オブジェクト
を探し，解放する．これを sweep という．</p>
<p>次のコードのようなデータ型とルーチンを定義する．</p>
<p>bt は，参照である left と right をもつ． left と right は， Mark&amp;Sweep が走査する
指標になっている．たとえば，ルートオブジェクトの left から参照されるオブジェクトは，
Mark フェイズで mark され， Sweep フェイズでは解放されることがない．
mark は， Mark フェイズでつける <em>しるし</em> のための領域だ． name は，オブジェクトが
GC されたとき，標準出力に書き出すための文字列で， GC が正しく動作しているか確認する
ために使用する．</p>
<p>gc のヒープは今のところ 2048 こしかオブジェクトを保存できない． heap.objects は
gc によって管理されるすべての bt へのポインタを記録している． heap.head は，次に
アロケートされるオブジェクトが記録される heap.objects のアドレスを指している．
root はルートオブジェクトを指している．
gc_run は gc を走らせ，不要なオブジェクトを解放する． gc_alloc は gc オブジェクト自体を
作成する． gc_malloc は gc のヒープ領域に新たなオブジェクトを確保する．</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define HEAP_SIZE 2048</span>

<span class="k">struct</span> <span class="n">bt</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">mark</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">gc</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">bt</span> <span class="o">**</span><span class="n">head</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">objects</span><span class="p">[</span><span class="n">HEAP_SIZE</span><span class="p">];</span>
  <span class="p">}</span> <span class="n">heap</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">gc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="nf">gc_alloc</span><span class="p">();</span>
<span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="nf">gc_malloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>あとは実装だ．</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;gc.h&quot;</span>

<span class="kt">void</span> <span class="nf">gc_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">bt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">bt</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">bt</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">gc_mark</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
  <span class="n">gc_mark</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gc_sweep</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HEAP_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">bt</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">bt</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">bt</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">bt</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;The binary tree %s is freed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span> <span class="n">bt</span> <span class="p">);</span>

      <span class="cm">/* gc-&gt;heap.objects[i] はもはや使用されないので再利用する．</span>
<span class="cm">       * ヒープのいちばん後ろにあるオブジェクトを前にここに詰める． */</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span><span class="o">--</span><span class="p">;</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
      <span class="o">*</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/* gc-&gt;heap.objects[i] を再利用したので，もういちど同じ場所を走査する． */</span>
      <span class="n">i</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gc_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gc_mark</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
  <span class="n">gc_sweep</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="nf">gc_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span><span class="p">));</span>
  <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">objects</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">gc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="nf">gc_malloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="n">gc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span> <span class="o">-</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">objects</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">HEAP_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;user error: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="n">bt</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bt</span><span class="p">));</span>
  <span class="n">bt</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
  <span class="o">*</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">bt</span><span class="p">;</span>
  <span class="n">gc</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">.</span><span class="n">head</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">bt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>テストコード．</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;gc.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">gc</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">gc_alloc</span><span class="p">();</span>
    <span class="n">gc</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">gc_malloc</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="s">&quot;root&quot;</span><span class="p">);</span>
    <span class="n">gc</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">gc_malloc</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="s">&quot;root-&gt;left&quot;</span><span class="p">);</span>
    <span class="n">gc</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">gc_malloc</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="s">&quot;root-&gt;right&quot;</span><span class="p">);</span>
    <span class="n">gc_malloc</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="s">&quot;free&quot;</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;run gc first.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">gc_run</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>

    <span class="n">gc</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bt</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;run gc second.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">gc_run</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>このコードは次のようにしてコンパイルできる．</p>
<div class="highlight-sh"><div class="highlight"><pre>gcc -Wall -std<span class="o">=</span>c99 gc.c test.c
</pre></div>
</div>
<p>このコードを実行すると，次のように表示されるはずだ．</p>
<div class="highlight-sh"><div class="highlight"><pre>./a.out
run gc first.
The binary tree free is freed.
run gc second.
The binary tree root-&gt;right is freed.
</pre></div>
</div>
<p>たしかに，正しく参照されていないオブジェクトが解放され，
参照されているオブジェクトは生き残っている．これにて実装は完了だ．</p>
</div>


    </div>

</body>
</html>