\documentclass{jarticle}
\usepackage{url}
\usepackage{listings}
\usepackage{../sty/epic}
\usepackage{../sty/eepic}
\usepackage{../sty/ecltree}

\title{文脈自由文法とパーサコンビネータ}
\author{Pasberth}
\date{December 20, 2013}

\begin{document}

\maketitle

\begin{abstract}
この文書は文脈自由文法とパーサコンビネータの簡単な教科書である．
これを読めば，きっと，文脈自由文法とパーサコンビネータを理解する手助けとなる
であろう．本書は主にHaskellにおけるパーサコンビネータを扱う．
たとえば，ParsecやAttoparsec，Trifectaの使い方を簡単に勉強するのが本書の
目標である．もしあなたがパーサコンビネータに興味があるなら，ぜひ手に
とってみてほしい．きっと役に立つだろう．
\end{abstract}

\tableofcontents

\section{はじめに}

\subsection{ソースコード}

この文書はオープンソースである．
完全なソースコードは，2013年12月20日現在，
\url{https://github.com/pasberth/pasberth.github.io/tree/default/papers/brief-intro-parser-combinators}で
公開されている．この文書自体のソースコードや，例に使用されるソースコードが
そこから入手できる．

\subsection{ソースコードの入手方法}

もっとも簡単な方法はgitを使用することである．
次のようなシェルコマンドで簡単に入手できる．


\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
git clone https://github.com/pasberth/pasberth.github.io.git
cd pasberth.github.io
git checkout default
cd papers/brief-intro-parser-combinators
\end{lstlisting}

\section{文脈自由文法}

言語の規定のために用いる概念である文脈自由文法({\it context-free grammer})
を導入する．文脈自由文法は略して文法({\it grammer})ということもある．

文法は，たいていの形式言語の構成要素がもつ階層構造を，自然な形で
表現したものである．たとえば，Javaのif-else文は，
\begin{center}
{\bf if} ( 式 ) 文 {\bf else} 文
\end{center}
である．すなわち，if-else文は，キーワード{\bf if}，左かっこ，式，右かっこ，
文，キーワード{\bf else}，そして1つの文を並べたものである．
式をあらわすための変数を{\it expr}，文をあらわすための変数を{\it stmt}とすると，
この構造化規則は，次のように表現できる．
\begin{center}
{\it stmt} $\longrightarrow$ {\bf if} ( {\it expr} ) {\it stmt} {\bf else} {\it stmt}
\end{center}
このような規則を{\bf 生成規則}とよぶ．
キーワード{\bf if}や``("のような字句表現を{\bf 終端記号}とよぶ．
{\it expr}や{\it stmt}のような変数を{\bf 非終端記号}とよぶ．

\subsection{文法の定義}

文法は次の4つの要素からなる．
\begin{itemize}
\item 終端記号({\it terminal symbol})の集合．
\item 非終端記号({\it nonterminal symbol})の集合．
\item 生成規則({\it production})の集合．
\item 開始記号としての，1つの非終端記号の指定．
\end{itemize}
文法は，生成規則を列挙することによってさだめられる．その際，開始記号に対する
生成規則を先頭におくようにする．{\bf if}や{\bf else}のように，太字であらわされた
記号は終端記号である．``("といった符号は終端記号である．
{\it expr}や{\it stmt}のようにイタリック体であらわされた
記号は非終端記号である．生成規則を，
\begin{center}
$\alpha \longrightarrow \beta_1 \beta_2 \ldots \beta_n$
\end{center}
のように書き，``$\alpha$は$\beta_1 \beta_2 \ldots \beta_n$という形式をもつことができる"と読む．
$\alpha$はその生成規則の{\bf 頭部}または{\bf 左辺}とよばれる．
$\beta_1 \beta_2 \ldots \beta_n$はその生成規則の{\bf 本体}または{\bf 右辺}とよばれる．

文脈自由文法でS式を定義する簡単な例を述べる．
まず，自然言語でS式を定義する．
\begin{enumerate}
\item 加算個の変数 $x_1,x_2,\ldots,x_n$ はS式である．
\item {\sl M}と{\sl N}がS式ならば，({\sl M}.{\sl N})はS式である．
\end{enumerate}
この定義から，たとえば，($x_1$.$x_2$)はS式であるとわかる．
これを文脈自由文法を用いて記述する．
\begin{enumerate}
\item {\it variable} $\longrightarrow$ $x_1$\\
      {\it variable} $\longrightarrow$ $x_2$\\
      :\\
      {\it variable} $\longrightarrow$ $x_n$
\item {\it s-expression} $\longrightarrow$ {\it variable}
\item {\it s-expression} $\longrightarrow$ ( {\it s-expression} . {\it s-expression} )
\end{enumerate}

\subsection{導出}

文法は，開始記号から出発して，非終端記号をそれに対する生成規則の本体で
おきかえる，という操作の繰り返しによって，記号列を導出する．開始記号から導出できる
ことのできる終端記号列が，その文法によって定義される言語を形成する．

たとえば， ($x_1$.$x_2$) が {\it s-expression} であることは，次のようにして説明できる．

\begin{enumerate}
\item 生成規則(1)から $x_1$ は {\it variable} なので，
      生成規則(2)から $x_1$ は {\it s-expression} である．
\item 生成規則(1)から  $x_2$ は {\it variable} なので，
      生成規則(2)から $x_2$ は {\it s-expression} である．
\item $x_1$ と $x_2$ は {\it s-expression} なので，
      生成規則(3) から ($x_1$.$x_2$) は {\it s-expression} である．
\end{enumerate}

\subsection{解析木}

解析木({\it parse tree})は，言語に含まれる文字列が，その文法の開始記号から，
どのように導出できるかを図式したものである．解析木のことを，構文木({\it syntax tree})と
いうこともある．解析木を形式的に定義することもできるが，
ここでは例を見て理解してほしい．次の図は， ($x_1$.$x_2$) の解析木である．
\begin{center}
\GapDepth=20pt
\GapWidth=40pt
\begin{bundle}{{\it s-expression}}
\chunk{(}
\chunk
{
\begin{bundle}{{\it s-expression}}
\chunk
{
\begin{bundle}{{\it variable}}
\chunk{$x_1$}
\end{bundle}
}
\end{bundle}
}
\chunk{.}
\chunk
{
\begin{bundle}{{\it s-expression}}
\chunk
{
\begin{bundle}{{\it variable}}
\chunk{$x_2$}
\end{bundle}
}
\end{bundle}
}
\chunk{)}
\end{bundle}
\end{center}

\subsection{抽象構文木}

抽象構文木({\it abstract syntax tree})は，解析木からよけいな文字を取り除いたものである．
たとえば，($x_1$.$x_2$)の解析木に``("や``."や``)"といった文字が含まれるが，情報として
必要とは思えない．なぜならば，これがあったとしてもなかったとしても，それが定義(3)のものだと
はっきりわかるからである．しかし，$x_1$や$x_2$は情報として必要である．``("や``."や``)"と
いった文字を取り除き，$x_1$や$x_2$のみを含む木を抽象構文木という．ここでは例をみて理解して
ほしい．
\begin{center}
\GapDepth=20pt
\GapWidth=40pt
\begin{bundle}{{\it s-expression}}
\chunk
{
\begin{bundle}{{\it s-expression}}
\chunk
{
\begin{bundle}{{\it variable}}
\chunk{$x_1$}
\end{bundle}
}
\end{bundle}
}
\chunk
{
\begin{bundle}{{\it s-expression}}
\chunk
{
\begin{bundle}{{\it variable}}
\chunk{$x_2$}
\end{bundle}
}
\end{bundle}
}
\end{bundle}
\end{center}


\section{パーサコンビネータ}

パーサコンビネータは，文脈自由文法をそのままに書けるパーサだと思えばよろしい．
パーサコンビネータの実装には，Haskellでは，
Parsec\footnote{\url{http://hackage.haskell.org/package/parsec}}，
Attoparsec\footnote{\url{http://hackage.haskell.org/package/attoparsec}}，
Trifecta\footnote{\url{http://hackage.haskell.org/package/trifecta}}
などがある．たとえば，冒頭で述べたJavaのif-else文を，HaskellのParsecであらわすと，
次のようになる．
\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
import qualified Text.Parsec as P

expr :: Monad m => P.ParsecT String u m ()
expr = return ()

stmt :: Monad m => P.ParsecT String u m ()
stmt = P.string "if" >>
        P.char '(' >> expr >> P.char ')' >>
        stmt >> P.string "else" >> stmt
\end{lstlisting}
キーワード{\bf if}は{\tt P.string "if"}のようにして
あらわす．カッコは{\tt P.char '('}のようにしてあらわす．
変数はHaskellにおける識別子であらわす．そして，
それぞれの記号を``\verb|>|\verb|>|"で繋ぐ．
記号を置き換えて読んでみれば，このコードが生成規則をそのまま写したものであるように
見えるのはわかるであろう．

\subsection{正規表現とパーサコンビネータ}

もし正規表現がわかるなら，正規表現を翻訳してみるのがパーサコンビネータを理解する
早道である．たとえば，正規表現{\tt /abc/}を考えてみよう．これは，正規表現の
文法にしたがえば，abcという文字列にマッチする．これをパーサコンビネータに
翻訳すると，{\tt string "abc"}となる．正規表現というならば，当然{\tt *}や{\tt +}
といったオペレータをもつのではないかと疑問に思うだろう．たとえば，{\tt /a*/}はどのように
翻訳されるのか？　答えは，{\tt many (string "a")}である．簡単な対応表を以下に示す．
ここで$\alpha \Longrightarrow \beta$は``$\alpha$は$\beta$に翻訳される"と読む．
ただし，正規表現はPerlのものを意図している．

\begin{itemize}
\item {\tt /x/} $\Longrightarrow$ {\tt string "x"}
\item {\tt /x*/} $\Longrightarrow$ {\tt many (string "x")}
\item {\tt /x+/} $\Longrightarrow$ {\tt many1 (string "x")} または {\tt some (string "x")} (実装によって異なることに注意する．)
\item {\tt /x?/} $\Longrightarrow$ {\tt optional (string "x")}
\item {\tt /x(?R)|\$/} $\Longrightarrow$ {\tt let r = do \{ string "x"; r \verb|<|\verb|||\verb|>| string "$\backslash$n" \}}
\end{itemize}

\section{付録}

簡単なS式パーサの完全な実装をParsec，Attoparsec，Trifectaそれぞれで例として示す．
例のコードはすべて同じ仕様である．例のコードの仕様は，引数なしでコマンドラインから
起動されると，まず1行入力を受け付ける．そしてその行をS式としてパースし，
問題なくパースできたか失敗したかを人間が目で見て判断できるような結果を
出力する．

たとえば，Trifectaの例は，1行目に次のように与えると，
\begin{lstlisting}
(x1.x2)
\end{lstlisting}
次のように出力する．これは抽象構文木を文字の列として表現したものである．
\begin{lstlisting}
Cons (Sym "x1") (Sym "x2")
\end{lstlisting}
1行目に次のように与えると，
\begin{lstlisting}
(x1.x2
\end{lstlisting}
次のように出力する．これはエラーメッセージである．
\begin{lstlisting}
(interactive):1:7: error: unexpected EOF, expected: ")",
    white space
(x1.x2<EOF>
      ^
\end{lstlisting}

付録のサンプルコードをビルドするには，まず本書のソースコードを手に入れて，
本書のソースコードがあるディレクトリまでいく．そしてそのあと，
cabal-devを使用してビルドできる．./cabal-dev/bin以下に
バイナリが用意される．
\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
git clone https://github.com/pasberth/pasberth.github.io.git
cd pasberth.github.io
git checkout default
cd papers/brief-intro-parser-combinators
cabal-dev install
ls ./cabal-dev/bin
\end{lstlisting}

\subsection{Parsec}

Parsecはパーサコンビネータの実装のひとつで，Haskellで書かれている．
以下に，ParsecでS式をパースする完全な例を示す\footnote{
ファイルは
\url{https://raw.github.com/pasberth/pasberth.github.io/default/papers/brief-intro-parser-combinators/sexp-parsec.hs}
から入手できる．}．
\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
import qualified Text.Parsec as P

data SExp
  = Sym String
  | Cons SExp SExp
  deriving (Show)

sym :: Monad m => P.ParsecT String u m SExp
sym = do
  s <- P.many1 $ P.noneOf "(.) \t"
  return $ Sym s

cons :: Monad m => P.ParsecT String u m SExp
cons = do
  P.char '('
  P.spaces
  x <- sexp
  P.spaces
  P.char '.'
  P.spaces
  y <- sexp
  P.spaces
  P.char ')'
  return $ Cons x y

sexp :: Monad m => P.ParsecT String u m SExp
sexp = cons P.<|> sym

main :: IO ()
main = do
  s <- getLine
  let result
        = P.parse
            (do { x <- sexp ; P.eof ; return x })
            "<stdin>"
            s
  print result
\end{lstlisting}

\subsection{Attoparsec}

Attoparsecはパーサコンビネータの実装のひとつで，Haskellで書かれている．
ByteStringを使用するのでParsecより高速である．
以下に，AttoparsecでS式をパースする完全な例を示す\footnote{
ファイルは
\url{https://raw.github.com/pasberth/pasberth.github.io/default/papers/brief-intro-parser-combinators/sexp-attoparsec.hs}
から入手できる．}．
\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}

import qualified Control.Applicative as A
import qualified Data.ByteString as B
import qualified Data.Attoparsec as P
import qualified Data.Attoparsec.ByteString.Char8 as P8

data SExp
  = Sym String
  | Cons SExp SExp
  deriving (Show)

sym :: P.Parser SExp
sym = do
  s <- P.many1 $ P8.satisfy (not . (`elem` "(.) \t"))
  return $ Sym s

cons :: P.Parser SExp
cons = do
  P8.char '('
  P.many' P8.space
  x <- sexp
  P.many' P8.space
  P8.char '.'
  P.many' P8.space
  y <- sexp
  P.many' P8.space
  P8.char ')'
  return $ Cons x y

sexp :: P.Parser SExp
sexp = cons A.<|> sym

main :: IO ()
main = do
  s <- B.getLine
  let result
        = P.parse sexp s
  print $ P.eitherResult result
\end{lstlisting}

\subsection{Trifecta}

Trifectaはパーサコンビネータの実装のひとつで，Haskellで書かれている．
今回紹介した3つのなかではいちばん新しく，高度に抽象化されているので，今イチバン
イケてる実装である．
以下に，TrifectaでS式をパースする完全な例を示す\footnote{
ファイルは
\url{https://raw.github.com/pasberth/pasberth.github.io/default/papers/brief-intro-parser-combinators/sexp-trifecta.hs}
から入手できる．}．
\lstset{basicstyle=\ttfamily,}
\begin{lstlisting}
import qualified Control.Applicative as A
import qualified Text.Trifecta as P

data SExp
  = Sym String
  | Cons SExp SExp
  deriving (Show)

sym :: P.Parser SExp
sym = do
  s <- A.some $ P.noneOf "(.) \t"
  return $ Sym s

cons :: P.Parser SExp
cons = do
  P.char '('
  P.spaces
  x <- sexp
  P.spaces
  P.char '.'
  P.spaces
  y <- sexp
  P.spaces
  P.char ')'
  return $ Cons x y

sexp :: P.Parser SExp
sexp = cons A.<|> sym

main :: IO ()
main = do
  s <- getLine
  P.parseTest (do { x <- sexp ; P.eof ; return x }) s
\end{lstlisting}

\subsection{おまけ: Applicative}

Control.ApplicativeはHaskellの標準ライブラリである．
これを使用すると，パーサコンビネータをよりスマートに利用できる．
前の節で書いたTrifectaを使用したコードをApplicativeを使用して書き直す例を示す\footnote{
ファイルは
\url{https://raw.github.com/pasberth/pasberth.github.io/default/papers/brief-intro-parser-combinators/sexp-trifecta-applicative.hs}
から入手できる．}．
\begin{lstlisting}
import           Control.Applicative
import qualified Text.Trifecta as P

data SExp
  = Sym String
  | Cons SExp SExp
  deriving (Show)

sym :: P.Parser SExp
sym = Sym <$> (some $ P.noneOf "(.) \t")

cons :: P.Parser SExp
cons = Cons <$> (P.char '(' *> P.spaces *> sexp)
            <* P.spaces <* P.char '.'
            <*> sexp <* P.spaces <* P.char ')'

sexp :: P.Parser SExp
sexp = cons <|> sym

main :: IO ()
main = do
  s <- getLine
  P.parseTest (sexp <* P.eof) s
\end{lstlisting}

\begin{thebibliography}{数字}
\bibitem{dragonbook} コンパイラ―原理・技法・ツール
\end{thebibliography}

\end{document}